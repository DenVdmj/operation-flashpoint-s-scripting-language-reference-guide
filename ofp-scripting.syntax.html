<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Язык описания сценариев игры Operation Flashpoint. Справочное руководство. Синтаксис языка.</title>
<link href=".rsc/style.css" rel="stylesheet" type="text/css" />
<script src=".rsc/init.js"></script>
<script src="hyphened-text.js"></script>
</head>
<body>

<ul class="toc">
<li><a href="#toc00">Синтаксис языка</a>
    <ul>
    <li><a href="#toc01">Sqs скрипты</a>
    <ul>
        <li><a href="#toc02">Выполнение sqs скриптов</a></li>
        <li><a href="#toc03">Построковая структура sqs скрипта</a></li>
        <li><a href="#toc04">Передача и получение аргументов скрипта</a></li>
        <li><a href="#toc05">Комментарии</a></li>
        <li><a href="#toc06">Операторы управления процессом вычисления</a><ul>
            <li><a href="#toc07">Оператор условного выполнения ?:</a></li>
            <li><a href="#toc08">Метки и оператор goto</a></li>
            <li><a href="#toc09">Ожидание выполнения указанного условия @</a></li>
            <li><a href="#toc10">Ожидание наступления указанного времени &amp;</a></li>
            <li><a href="#toc11">Пауза ~</a></li>
            <li><a href="#toc12">Выход из скрипта</a></li>
        </ul>
        </li>
    </ul>
    </li>
    <li><a href="#toc13">Sqf функции
    </a><ul>
        <li><a href="#toc14">Выполнение sqf функций</a></li>
        <li><a href="#toc15">Блочная структура функций</a></li>
        <li><a href="#toc16">Передача и получение аргументов функций</a></li>
        <li><a href="#toc17">Возвращаемое значение</a></li>
        <li><a href="#toc18">Комментарии</a></li>
        <li><a href="#toc19">Макро</a></li>
        <li><a href="#toc20">Операторы управления процессом вычисления
        </a><ul>
            <li><a href="#toc21">Оператор условного выполнения if then else</a></li>
            <li><a href="#toc22">Оператор цикла while do</a></li>
            <li><a href="#toc23">Оператор поэлементного обхода массива foreach</a></li>
            <li><a href="#toc24">Косвенный вызов функций или имитирование оператора switch</a></li>
        </ul>
        </li><li><a href="#toc25">Рекурсивные функции</a></li>

    </ul>
    </li>
</ul>
</li>
</ul>

<h3 id="toc00">Синтаксис языка</h3>

<p>Код, записанный на скриптовом языке, состоит из команд и их операндов. Несмотря на то, что в оригинальном
комрефе разработчики игры не делят команды на операторы, функции, ключевые слова и т.д. мы будем
<span tooltip="Это типа отмазка такая, почему я тут назвал это так, а в другом месте подругому. Пишу как умею :-)">иногда</span>
проводить такое деление. Например, команды математических операций и команды управления выполнением будут часто называться операторами,
а команды возвращающие значение — функциями (как, например, математические функции), хотя иногда я буду забывать об этом и называть их просто командами.</p>

<p>Некоторые команды могут возвращать значение, самой близкой аналогией здесь может быть пример из математики: мы говорим, что функция sin
возвращает синус аргумента. Аналогично и в языках программирования — запись <tt>sin(x)</tt> вернёт синус <tt>x</tt>.</p>

<p>Одни команды не имеют операндов, например команда <tt>player</tt> всегда возвращает ссылку на игрока, а команду <tt>west</tt>
можно было бы назвать зарезервированной константой, так как она также всегда возвращает одно и то же значение — сторону <tt>west</tt>.</p>

<p>Другие команды могут иметь один или два операнда:
если у команды один операнд, то он всегда правый, иначе, это левый и правый операнды.
Если же команде требуется больше данных, то один из операндов будет массивом,
при этом команда может иметь <span tooltip="Например команда action, ей бывает нужна куча данных и поэтому она принимает массив левым операндом, хотя и правый тоже есть.
Другой пример: nearestObject — в частном случае ей нужна позиция и имя класса объекта, но у команды, тем не менее, не два операнда, а один операнд-массив. Вывод следующий — читайте комреф.
">как один, так и два операнда</span>.
Чтобы всегда быть уверенными в том верно ли вы используете ту или иную команду,
лучше всего всегда иметь под рукой комреф или один из нескольких его переводов.</p>

<p>Команды можно объединять в более сложные выражения,
например такое выражение, вернёт водителя техники, в которой находится
<span tooltip="Подразумевается, что он есть, если количество членов отряда меньше двух, пример будет давать ошибку.
Это учебный пример — на практике такие допущения делать нельзя!">«Второй» отделения игрока</span>:</p>


<pre class="hl"><u>driver vehicle</u> <b>(</b><u>units player</u> <b>select</b> 1<b>)</b></pre>

<p>Откройте комреф и посмотрите описание следующих команд:
<tt tooltip="Синтаксис: driver vehicle;
Операнды: Object vehicle;
Тип возвращаемого значения: Object;
Описание: Возвращает водителя техники vehicle, если vehicle - человек, то будет возвращен сам человек.">driver</tt>,
<tt tooltip="Синтаксис: vehicle unit;
Операнды: Object unit;
Тип возвращаемого значения: Object;
Описание: Возвращает технику в которой в данный момент находится юнит unit. Если юнит не в технике, возвращается сам юнит.">vehicle</tt>,
<tt tooltip="Синтаксис: units unit;
Операнды: Object unit;
Тип возвращаемого значения: Array;
Описание: Возвращает массив всех юнитов являющихся членами отряда юнита unit. Если юнит unit мертв, будет возвращен пустой массив.
">units</tt>,
<tt tooltip="Синтаксис: player;
Тип возвращаемого значения: Object;
Описание: Персонаж управляемый игроком. В мультиплеер-режиме это значение различно на разных компьютерах
">player</tt> и
<tt tooltip="Синтаксис: array select index;
Операнды: Array array, Number index;
Тип возвращаемого значения: Any Value;
Описание: Возвращает элемент массива array указанный операндом index. Элементы массива нумеруются с нуля, так массив состоящий из пяти элементов, индексируется значениями от 0 до 4.
">select</tt>.
После того как мы ознакомились с описанием команд, отметили про себя количество и типы их операндов, мы
можем подробно рассмотреть, как будет вычисляться этот код интерпретатором:</p>
<pre class="code"><s>Синим курсивом выделено текущее подвыражение вычисляемое
интерпретатором; зеленым — промежуточный результат вычислений

Этап 1</s>
driver vehicle (<em>units player</em> select 1)
                <em>units player</em>          <s>-&gt; вернёт массив солдат</s>
                   <tt>массив</tt>             <s>-&gt; Array type</s>

<s>Этап 2</s>
driver vehicle (<em>массив select 1</em>)
                <em>массив select 1</em>       <s>-&gt; вернёт солдата</s>
                   <tt>солдат</tt>             <s>-&gt; Object type</s>

<s>Этап 3</s>
driver <em>vehicle солдат</em>
       <em>vehicle солдат</em>                 <s>-&gt; вернёт грузовик</s>
         <tt>грузовик</tt>                     <s>-&gt; Object type</s>

<s>Этап 4</s>
<em>driver грузовик</em>                       <s>-&gt; вернёт водителя</s>
   <tt>водитель</tt>                           <s>-&gt; Object type</s></pre>

<p>Это значение (водитель) может использоваться в дальнейшем, например, так мы записываем его в переменную _my_driver,
а затем отбираем у него все оружие:</p>
<pre class="hl">_my_driver <b>=</b> <u>driver vehicle</u> <b>(</b><u>units player</u> <b>select</b> 1<b>)</b>
<u>removeAllWeapons</u> _my_driver</pre>

<p>или делаем это одним выражением:</p>
<pre class="hl"><u>removeAllWeapons driver vehicle</u> <b>(</b><u>units player</u> <b>select</b> 1<b>)</b></pre>

<p><i>Примечание: здесь используется допущение, что нужный нам водитель и второй номер группы игрока существуют,
если эти условия не будут выполняться — скрипт выдаст ошибку; это учебный пример, в действительной практике нужно выполнять явные проверки.</i></p>

<p>Возможность возвращать значение — очень важный момент, поскольку построение сложных (комплексных, составных) выражений
синтаксически основано именно на том, что команды могут иметь операнды и возвращать значения.
Поэтому, при разборе и написании выражений часто удобно думать, что круглые скобки возвращают своё содержимое,
переменная возвращает своё значение, а непосредственно указанное число возвращает самоё себя.</p>

<p>При вычислении выражений языка учитывается приоритет выполнения команд.
Аналогично тому, как в математической записи <nobr>« <tt>X + Y * Z</tt> »</nobr> вначале будет выполнено
умножение <nobr>« <tt>Y * Z</tt> »</nobr> и затем его результат будет сложен с X,
так и в выражениях  рассматриваемого языка вначале выполняются команды, имеющие больший приоритет.
В основном, это важно при использовании математических и логических операций, при равенстве приоритетов код разбирается слева направо,
круглые скобки всегда имеют высший приоритет. Более подробно о приоритетах рассказано в <a href="ofp-scripting.variable.html">главе «Переменные»</a>.</p>


<h4 id="toc01">Sqs скрипты</h4>
<h5 id="toc02">Выполнение sqs скриптов</h5>

<p>Каждый скрипт, запущенный на выполнение командой <tt>exec</tt>, будет работать в отдельном параллельном потоке
со своей собственной областью данных под локальные переменные. Вызывающая сторона после выполнения
команды <tt>exec</tt> переходит к следующей команде в потоке, не дожидаясь завершения запущенного скрипта.</p>

<p>Параллельно с выполнением команд sqs-скрипта в игре могут происходить различные события,
и фактически выполнение команд одного скрипта происходит с определёнными микропаузами.
Это следует учитывать, так как в редких случаях результат проверки некоторого
условия (например, жив ли персонаж, с которым мы работаем)
десятками строк ранее (в основном это будет долгий цикл), может стать неактуальным строкой ниже.</p>
<h5 id="toc03">Построковая структура sqs скрипта</h5>

<p>Скрипт sqs имеет построковую структуру, другими словами, самостоятельные выражения должны отделяться друг от друга символом конца строки.
С момента введения в язык функций sqf стало возможным использовать для этого «точку с запятой» («;») и записывать в одной строке
более одного выражения, однако надо следить, чтобы символ «;» не стоял в строке первым, поскольку ранее было решено зарезервировать
такую конструкцию за комментарием. Также в sqs скриптах возможны все операторы sqf функций (if then else, while do,
<span tooltip="Автор погрешил против истины назвав foreach оператором sqf функций. На самом деле foreach существовал и до появления в языке sqf, однако по ряду причин нам удобнее будет рассмотреть его в главе о функциях.
">foreach</span>), однако записываться они должны в одну строку,
что очень затрудняет написание и ухудшает читабельность такого кода.</p>
<h5 id="toc04">Передача и получение аргументов скрипта</h5>

<p>Как мы уже знаем, скрипт вызывается следующей конструкцией:</p>
<pre class="hl">«arg» <b>exec</b> <i>"script_filename.sqs"</i></pre>

<p>«arg» — передаваемый в скрипт параметр.</p>

<p>Интерпретатор не поддерживает передачу списка аргументов (и соответственно обращения к ним по имени из скрипта),
поэтому чтобы передать более одного аргумента мы должны использовать массив:</p>
<pre class="hl"><b>[</b>_arg0<b>,</b> _arg1<b>,</b> _arg2<b>] exec</b> <i>"my_script.sqs"</i></pre>

<p>С другой стороны, синтаксис команды exec обязывает нас всегда указывать её левый операнд,
даже если мы не хотим ничего передавать в скрипт. В качестве фиктивного аргумента вполне подойдёт ноль:</p>
<pre class="hl">0 <b>exec</b> <i>"some_script.sqs"</i></pre>

<p>Переданный параметр доступен из скрипта как предопределённая переменная <tt>_this</tt>.</p>

<p><i>Примечание: в ранних версиях игры единственным допустимым типом левого операнда exec был <tt>Array</tt>,
поэтому сложилось так, что самым популярным вариантом вызова без параметров стала передача пустого массива: «<tt>[] exec "scriptname.sqs"</tt>».</i></p>

<p>Как уже сказано, за убогостью языковых средств, для передачи ряда аргументов нам приходится использовать массив, таким образом,
чтобы удобно обращаться к каждому из них по имени мы сами должны создать переменные
и записать в них соответствующие элементы массива.
Получить указанный элемент массива позволяет команда <tt>select</tt>:</p>
<pre class="hl">_arg0 <b>= _this select</b> 0
_arg1 <b>= _this select</b> 1
_arg2 <b>= _this select</b> 2</pre>

<p>Если же мы передавали в скрипт скаляр, то для обращения к нему можно непосредственно использовать <tt>_this</tt>.</p>
<h5 id="toc05">Комментарии</h5>

<p>Комментарий в sqs синтаксисе записывается как отдельная строка предварённая символом «;». Может смутить,
что тот же символ используется для разделения выражений записанных в одну линию, поэтому следите, чтобы комментарий
всегда стоял отдельной строкой.</p>

<pre class="hl"><s>; Это комментарий, здесь можно писать что угодно, но лучше
; комментировать свой код, хотя бы для себя.</s></pre>

<h5 id="toc06">Операторы управления процессом вычисления</h5>

<p>Sqs скрипт небогат на возможности управления потоком выполнения, помимо разного рода задержек
(или приостановок выполнения, о них ниже), все, что есть в нашем распоряжении — это
оператор условного выполнения «<tt>?:</tt>» и безусловный переход <tt>goto</tt></p>
<h6 id="toc07">Оператор условного выполнения ?:</h6>

<p>Оператор имеет синтаксис «<tt>? condition : expression</tt>» и в чем-то схож с <tt>if then else</tt> с «урезанным»
<tt>else</tt> — выражение <tt>expression</tt> будет выполнено лишь в том случае, если условие <tt>condition</tt> вернёт true.</p>

<p><i>Примечание для тех, кто знаком с языком C — оператор не имеет ничего общего с привычным тернарным «<tt>?:</tt>»,
в sqs этот оператор отличается семантикой, имеет два операнда и не возвращает значения.
Заменой тернарному оператору «?:» может служить select с булевым правым операндом,
а также (приятный сюрприз!) «if then else» — в рассматриваемом языке он возвращает значение (см. <a href="#AboutIfThenElse">детали</a>)
</i></p>

<p>Например, выйдем из скрипта, если он получил пустой массив в качестве аргумента:</p>
<pre class="hl"><b>?</b> <u>count</u> <b>_this ==</b> 0 <b>: exit</b></pre>

<p>Но в большинстве случаев мы хотим выполнять не одно выражение, а несколько; если их немного можно
использовать «;» для того, чтобы записать их в одной строке:</p>
<pre class="hl"><b>?</b> <u>count</u> <b>_this ==</b> 0 <b>:</b> <u>hint</u> <i>"Ошибка: не передано ни одного агрумента!"</i>; <b>exit</b></pre>
<h6 id="toc08">Метки и оператор goto</h6>

<p>Однако когда мы хотим выполнить более значительный объем кода, этот вариант совершенно не годится, и мы вынуждены
использовать оператор перехода <tt>goto</tt>.
Оператор осуществляет переход на указанную аргументом метку.
Метка должна стоять отдельной строкой и предваряться знаком шарп («#»).</p>

<p>Тот же код с использованием goto:</p>
<pre class="hl"><b>?!</b> <u>count</u> <b>_this ==</b> 0 <b>: goto</b> <i>"ок"</i>
<b>    </b><u>hint</u> <i>"Ошибка: не передано ни одного агрумента!"</i>
<b>    exit
#ок</b></pre>

<p>Фактически, скудный набор (или <span tooltip="О да, это не последняя подколка, любим сладкое — дружно отправляемся кодить в асм, там так сладко, что одно место может слипнуться ))">сладкая парочка</span>, судя по популярности sqs в отличие от sqf) из goto и
оператора условного выполнения позволяет реализовать весь спектр средств управления потоком.
Хотя это и не самый удобный вариант в сравнении с готовыми возможностями sqf, но если уж использовать goto,
то знать о них надо. Рассмотрим самые распространённые.</p>

<p>Конструкцию «если ... то ... иначе» короче всего можно записать если
изменить условие на обратное — обратите внимание на оператор «нот» («!»):</p>
<pre class="hl"><b>?!</b> «condition» <b>: goto</b> <i>"else"</i>
<s>    ; код выполняемый если «condition» истинно</s>
<b>    goto</b> <i>"endif"</i>
<b>#else</b>
<s>    ; код выполняемый если «condition» ложно</s>
<b>#endif</b></pre>

<p>В случае отсутствия части <tt>else</tt>, все упрощается до следующего:</p>
<pre class="hl"><b>?!</b> «condition» <b>: goto</b> <i>"endif"</i>
<s>    ; код выполняемый если «condition» истинно</s>
<b>#endif</b></pre>

<p>Так записывается цикл «do ... while ... », проверка условия выполняется в конце, т.о.
тело цикла всегда выполняется, по меньшей мере, один раз:</p>
<pre class="hl"><b>#do</b>
<s>    ; тело цикла выполняемое пока «condition» истинно</s>
<b>?</b> «condition» <b>: goto </b><i>"do"</i></pre>

<p>Цикл «while ... do ... ».
В отличие от предыдущего «do while»,
тело цикла «while do» может не выполнится ни разу (проверка его условия выполняется в начале). Обычно этот цикл записывают так:</p>
<pre class="hl"><b>#while
    ?!</b> «condition» <b>: goto</b> <i>"end_loop"</i>
<s>    ; тело цикла выполняемое пока «condition» истинно</s>
<b>goto </b><i>"while"</i>
<b>#end_loop</b></pre>

<p>Однако существует <span tooltip="В кругах людей занимающихся программированием на языках, вынуждающих использовать условные переходы">вариант более популярный</span> (он выносит из цикла лишний оператор):</p>
<pre class="hl"><b>goto</b> <i>"loop_entry"</i>
<b>#while</b>
<s>    ; тело цикла выполняемое пока «condition» истинно</s>
<b>    #loop_entry
?</b> «condition» <b>: goto</b> <i>"while"</i></pre>

<p>Аналогично записывается цикл со счетчиком:</p>
<pre class="hl">_counter <b>=</b> _start_number
<b>#loop</b>
<s>    ; тело цикла</s>
<b>    </b>_counter <b>=</b> _counter <b>+</b> 1
<b>?</b> _counter <b>!=</b> last_number <b>: goto </b><i>"loop"</i></pre>

<p>«Swicth» или выбор ветвления по ключу, имеющему тип <tt>String</tt>:</p>
<pre class="hl"><b>?</b> _key <b>in [</b><i>"c1"</i><b>,</b> <i>"c2"</i><b>,</b> <i>"c3"</i><b>] : goto</b> _key
<b>goto</b> <i>"default"</i>

<b>#c1</b>
<s>    ; выбор s1</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#c2</b>
<s>    ; выбор s2</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#c3</b>
<s>    ; выбор s3</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#default</b>
<s>    ; выбор по умолчанию</s>

<b>#end_switch</b></pre>

<p>Если значение, по которому надо сделать выбор не относится к типу <tt>String</tt>,
можно получить строку функцией <tt>format</tt> и затем использовать её в качестве цели <tt>goto</tt>.
Этот способ неплох для типов <tt>Number</tt> (но надо следить, чтобы величина была целым числом) и <tt>Side</tt>:</p>
<pre class="hl">_key <b>=</b> <u>side</u> zold
<s>; если есть метки для всех существующих сторон (лоджик, например,
; относится к собственной строне), то проверку можно опустить</s>
<b>?</b> _key <b>in [</b><em>west</em><b>,</b> <em>east</em><b>,</b> <em>resistance</em><b>,</b> <em>civilian</em><b>] : goto</b> <u>format</u> <b>[</b><i>"%1"</i><b>,</b> _key<b>]
goto</b> <i>"default"</i>

<b>#WEST</b>
<s>    ; выбор для стороны west</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#EAST</b>
<s>    ; выбор для стороны east</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#GUER</b>
<s>    ; выбор для стороны resistance</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#CIV</b>
<s>    ; выбор для стороны civilian</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#default</b>
<s>    ; выбор по умолчанию</s>

<b>#end_switch</b></pre>

<p>В случае, когда ключевые величины — целые числа, подряд следующие друг за другом лучше обойтись без
использования <tt>format</tt>:</p>
<pre class="hl"><s>; массив переходов</s>
_jmptbl <b>= [</b><i>"nA"</i><b>,</b> <i>"nB"</i><b>,</b> <i>"nC"</i><b>,</b> <i>"nD"</i><b>]</b>
<s>; если мы укладываемся в диапазон допустимых значений: перейти</s>
<b>?</b> _key <b>&gt;=</b> 0 <b>&amp;&amp;</b> _key <b>&lt;</b> <u>count</u> _jmptbl <b>: goto (</b> _jmptbl <b>select</b> _key <b>)
goto</b> <i>"default"</i>

<b>#nA</b>
<s>    ; выбор nA</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#nB</b>
<s>    ; выбор nB</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#nC</b>
<s>    ; выбор nC</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#nD</b>
<s>    ; выбор nD</s>
<b>    goto</b> <i>"end_switch"</i>

<b>#default</b>
<s>    ; выбор по умолчанию</s>

<b>#end_switch</b></pre>

<p>Таблица переходов _jmptbl содержит имена меток для перехода,
но возможны и другие варианты с таблицами имён других sqs-скриптов, sqf-функций, а также содержащие sqf код непосредственно;
все это даёт интересные возможности при реализации алгоритмов.</p>

<p>Подводя черту под этим обзором, необходимо отметить один момент.
Когда бы ни использовался оператор «goto» вы должны чётко представлять
себе ту управляющую конструкцию, в которой он задействован. Логика кода должна
быть очевидной, поэтому не стоит злоупотреблять этим оператором.
Единственной оговоркой может быть следующее — во всех типах циклов с помощью <tt>goto</tt> можно имитировать
операторы «break» (досрочный выход из цикла) и «continue»
(досрочная передача управления в начало цикла), это вполне допустимо и не должно ухудшить код.
Можно также порекомендовать, использовать вложенные отступы для лучшего зрительного восприятия кода,
как если бы вы писали на C (или другом высокоуровневом языке), в противоположность тому, как это обычно принято в asm.</p>

<p>И всегда, когда есть такая возможность, старайтесь использовать возможности sqf-функций.</p>
<h6 id="toc09">Ожидание выполнения указанного условия @</h6>

<p>Часто в сценарии нам нужно приостановить выполнение скрипта до наступления какого-либо
события или просто на некоторое время, для этих случаев у sqs скриптов есть несколько удобных инструментов:
это операторы
«<tt>@</tt>» — ждёт выполнения условия,
«<tt>&amp;</tt>» — ждёт до указанного момента и
«<tt>&amp;</tt>» — пауза.</p>

<p>Оператор «<tt>@</tt>» ожидает наступления выполнения указанного нами условия, приостанавливая на
время ход работы скрипта.
Синтаксис оператора прост:</p>
<pre class="hl"><b>@</b> «condition»</pre>

<p>«condition» — любое выражение возвращающее true или false.</p>

<p>Фактически оператор выполняет выражение «condition» каждый такт игрового времени
и заканчивает свою работу, как только выражение вернёт true.
Например, следующий код ожидает посадку игрока в любую технику:</p>
<pre class="hl"><b>@</b> <u>vehicle player</u> <b>!=</b> <u>player</u></pre>

<p>Если мы хотим выполнять некоторые действия во время ожидания
(к примеру, проверку критического условия, когда дальнейшая работа скрипта не имеет смысла),
то можно разместить любое количество выражений в одну строку разделяя их символом «;»,
в таком случае условием будет считаться последнее указанное выражение:</p>
<pre class="hl"><b>@ if ( !</b> <u>alive</u> _soldier <b>) then { exit }</b>; <u>vehicle</u> _soldier <b>!=</b> _soldier</pre>

<p>Если условие нетривиально и код перестаёт умещаться в экранную ширину
(не более 80 символов), то код проверки удобно оформить sqf-функцией,
вынести её в отдельный файл и подключать через preprocessFile:</p>
<pre class="hl">_my_condition <b>=</b> <u>preprocessFile</u> <i>"my_condition.sqf"</i>
@ <b>call</b> _my_condition</pre>

<p>Всегда делайте это через переменную, это избавит скрипт от циклической загрузки файла.</p>
<h6 id="toc10">Ожидание наступления указанного времени &amp;</h6>

<p>Оператор «<tt>&amp;</tt>», приостанавливает ход работы скрипта до указанного аргументом времени:</p>
<pre class="hl">_waitUntil <b>= _time +</b> 10
<b>&amp;</b>_waitUntil</pre>
Данный пример ждёт десять секунд.

<p><i>Примечание: переменная _time содержит время прошедшее с начала старта скрипта</i></p>
<h6 id="toc11">Пауза ~</h6>

<p>Используется гораздо чаще предыдущего оператора, пример, приведенный выше может быть записан проще с помощью паузы «<tt>~</tt>»:</p>
<pre class="hl"><u>~</u> 10</pre>

<h6 id="toc12">Выход из скрипта</h6>

<p>Выход из скрипта должен осуществляться командой <tt>exit</tt>, часто её удобно
использовать для досрочного выхода из скрипта:</p>
<pre class="hl"><b>?</b> <u>count units player</u> <b>==</b> 0 <b>: exit</b></pre>

<p>Ну и, ради приличия, не забывайте добавлять её в конец каждого своего скрипта -))</p>
<h4 id="toc13">Sqf функции</h4>

<p>Функции sqf были добавлены в язык
<span tooltip="Можно заглянуть в комреф и выяснить версию игры в которой все это добро было предоставлено в наше распоряжение снизошедшими до простых смерных скриптовальщиков бисами">позднее</span>, и по
<span tooltip="Ну дык этож... sqs скрипты ж это как два пальца (goto и label), а энтот sqf, без сомнения, для извращенцев которым мало сёфпласпласов">ряду причин</span> получили меньшую популярность чем sqs скрипты.
Тем не менее, это наиболее удобное и мощное скриптовое средство, и
<span tooltip="На самом деле это не совсем так, при помощи стека меток, можно создать такую систему, однако это совсем низкоуровневое «скриптование», и кроме теоретического никакого иного интерса представлять не может ))">единственная
возможность создавать подпрограммы</span>.
Ранее в sqs скриптах не было механизма позволяющего выносить многократно
выполняющиеся действия в подпрограммы, что приводило в общем случае к дублированию кода,
и меньшей его прозрачности. Тот факт, что из одного sqs скрипта можно запустить другой мало спасает, так как
выполняться он будет как отдельная <span tooltip="Виртуальная машина. Имеется ввиду то, что запуск осуществляется в параллель.">ВМ</span>.</p>

<p>Sqf функции развивают идею интерпретируемых строк («code string»), использовавшихся ранее в
командах <span tooltip="Поэлементный обход массива">foreach</span> и двухоперандной форме
<span tooltip="Поэлементный обход массива с подсчетом итераций вернувших true">count</span>.
Поскольку рассматриваемый язык является интерпретируемым, то всегда существует возможность <span tooltip="Прямо во время работы программы">рантайм</span> <span tooltip="Синтаксического анализа">парсинга</span>
и выполнения любой строки содержащей выражения языка.
<span tooltip="А может просто так, от нефик делать. Бисы наперед знали, что никто юзать это не будет, иначе бы ни в жисть не добавили бы.">Чтобы сделать эту возможность более полной</span> были добавлены следующие команды:</p>
<table class="list">
<tbody>
<tr><th>call</th><th>—</th><td>самая важная, рапарсивает и выполняет строку, вызываемая сторона может получать аргументы, и возвращать значение</td></tr>
<tr><th>if then else</th><th>—</th><td>команды реализующие ветвление «если ... то ... иначе»</td></tr>
<tr><th>while do</th><th>—</th><td>команды реализующие цикл «пока ... выполнять ...»</td></tr>
<tr><th>private</th><th>—</th><td>теперь в одном файле может присутствовать несколько самостоятельных участков кода, и эта команда решает возникшую проблему с пространствами имён</td></tr>
<tr><th>loadFile</th><th>—</th><td>возвращает содержимое файла как строку</td></tr>
<tr><th>preprocessFile</th><th>—</th><td>содержимое файла обрабатывается си подобным препроцессором и возвращается как строка</td></tr>
</tbody>
</table>

<p>Для нас это в первую и главную очередь означает, что можно создавать свои функции и подпрограммы,
ну и конечно использовать средства управления потоком
<span tooltip="Есть еще «негры» (по крайней мере раньше были точно, даю зуб, что нескольких таких я видел (и даже пивал с ними пиво) в пору собственной интеллектуальной непорочности), кодящие в машинных кодах, они помнят размеры инструкций и подсчитывают смещения от условного джампа до цели перехода в уме.
Это конечно не тоже самое, что пользоваться goto, но «негры» то делают это по необходимости (или в силу особенности характера), а мы почему должны утруждать себя лишней работой?">специально
придуманные для «белых людей»</span>.
Их хоть и <span tooltip="Да-да, я хочу еще switch, ну можно еще do while, но не критично, а вот без break и continue порой неудобно, а еще очень хреново без хеш массивов, а символы строк брать нельзя и свои хеш массивы не сделаешь, вообще их даже сравнивать нельзя и призрачная надежда на бинарный поиск тает на глазах, полный попандос... пошел я кофе пить, расстройство одно">не много</span>,
этих средств, но нас, пишущих для офп, <span tooltip="Или нас густо? Если нас (или вас) «густо» пишите жалобу на ящик DenVdmj@yandex.ru, будем разбираться">тоже не густо</span>, так что нам пока хватит -))</p>

<p>Далее мы рассмотрим эти средства подробно.</p>
<h5 id="toc14">Выполнение sqf функций</h5>

<p>Как уже сказано, функция sqf представляет собой обычную строковую величину содержащую выражения языка.
Оператор <tt>call</tt> осуществляет вызов функции, фактически выполняя все выражения записанный в этой строке
и возвращая результат последнего вычисления.
Например, самая простая (и бесполезная) функция может выглядеть так:</p>
<pre class="hl">_units_player <b>=</b> <i>"units player"</i></pre>

<p>теперь вызов « <tt>call _units_player</tt> » вернёт массив юнитов игрока.
Здесь использовались двойные кавычки для того, чтобы подчеркнуть, что код выполняемый call — всего лишь строка,
однако рекомендуется использовать для этих целей исключительно фигурные скобки «{}».</p>

<p>Соответственно, чтобы выполнить любой sqf код размещенный в файле (рекомендуемое расширение .sqf)
необходимо предварительно получить строку командой preprocessFile и лишь затем вызвать оператором call:</p>
<pre class="hl"><b>call</b> <u>preprocessFile</u> <i>"my_function.sqf"</i></pre>

<p>Здесь, выражение « <tt>preprocessFile "my_function.sqf"</tt> » вернёт обработанное
препроцессором содержимое файла <i>"my_function.sqf"</i> в виде строки,
после чего, код записанный в этой строке выполнит команда call.
<i>(Препроцессор удалит коментарии и выполнит макроподстановку, подробнее об этом мы расскажем чуть позже.)</i></p>

<p>Теперь, ради удобства, мы можем благополучно забыть о том, что функции являются строками, и
будем вспоминать об этом лишь тогда, когда это понадобится непосредственно.</p>

<p>Функции могут принимать аргументы, так же как это делают sqs скрипты.
Пример функции возвращающей преобразованный в строку аргумент:</p>
<pre class="hl">_get_as_string <b>= {</b> <u>format</u> <b>[</b><i>"%1"</i><b>, _this] }</b></pre>

<p>Мы можем вызывать эту функцию так: « <tt>player call _get_as_string</tt> », проверим:</p>
<pre class="hl"><u>hint</u> <b>(</b> <u>player</u> <b>call</b> _get_as_string <b>)</b></pre>

<p>Одна sqf функция может содержать другие; например, создав файл с именем «my.sqf» и следующим содержанием:</p>
<pre class="hl"><b>private</b> <i>"_subfunction"</i>;

_subfunction <b>= {</b>
    <u>hint</u> <i>"эта функция находится в другой функции"</i>
<b>}</b>;

<b>call</b> _subfunction</pre>

<p>и вызвав его из инита игрока так: « <tt>call preprocessFile "my.sqf"</tt> »,
мы увидим появившуюся подсказку с текстом «эта функция находится в другой функции».</p>

<p>Функции sqf выгодно отличает от sqs скриптов то, что в процессе их выполнения не происходят игровые события,
то есть по внутриигровому времени они выполняются мгновенно. За это достоинство
приходится платить — в sqf невозможны приостановки, вечные циклы и прочее —
все то, что так необходимо в классическом сценарии. Другими словами sqf функции являются не заменой sqs
скриптов, а очень полезным и удобным дополнением.</p>
<h5 id="toc15">Блочная структура функций</h5>

<p>Функции состоят из выражений разделяемых символом «;».
Пример, демонстрирующий общий синтаксис sqf функции:</p>
<pre class="hl">_find_assoc_data <b>= {</b>

    <s>// обьявляем переменные приватными</s>
    <b>private[</b><i>"_value"</i><b>,</b> <i>"_array"</i><b>,</b> <i>"_index"</i><b>,</b> <i>"_ok"</i><b>]</b>;

    <s>// получаем аргументы и инициализируем переменные</s>
    _value <b>= _this select</b> 0;
    _array <b>= _this select</b> 1;
    _index <b>=</b> 0;
    _ok <b>=</b> <em>false</em>;

    <s>// макро с осмысленными именами для удобного доступа
    // к нужным элементам массива</s>
<u>    #define VALUE (( _array select _index ) select 0)
    #define DATA  (( _array select _index ) select 1)</u>

    <s>// сам алгоритм</s>
    <b>while { !</b>_ok <b>&amp;&amp;</b> _index <b>&lt;</b> <u>count</u> _array <b>} do {

        if (</b> VALUE <b>==</b> _value <b>) then {</b>
            _ok <b>=</b> <em>true</em>
        <b>} else {
            if (</b> VALUE <b>&gt;</b> _value <b>) then {</b>
                _index <b>=</b> _index <b>+</b> _index <b>+</b> 1
            <b>} else {</b>
                _index <b>=</b> _index <b>+</b> _index <b>+</b> 2
            <b>}</b>;
        <b>}</b>;
    <b>}</b>;

    <b>if (</b> _ok <b>) then {</b> DATA <b>} else { [] }
}</b></pre>

<p>Не будем вдаваться в то <span tooltip="Функа находит двоичным поиском ассоциированные со значением данные в специально сформированном массиве (пирамиде), это просто первый пришедший в голову популярный алгоритм">чем занимается эта функция</span>, пример приведен для общего представления синтаксиса.
Отметим, что нам не приходится конструировать руками цикл, мы используем для этого оператор while do.
Опять же, мы не строим нечитаемую конструкцию из меток и переходов для того, чтобы выполнить то или иное выражение —
просто используем «if then else».
Легко заметить, что нет необходимости записывать все выражения в одну строку, как это приходится делать в sqs.
Код становится читабельнее, и фигурные скобки вкупе с отступами «лесенкой» удобно отмечают начало и конец
каждого логического блока.</p>

<p>Да, поскольку в названии главы значится «блочная структура», придется сказать об этом пару слов.
Так как функции фактически состоят из операторов управления потоком и их операндов
(<i>именно так, поскольку это обычные команды принимающие строковые аргументы</i>),
а также учитывая то, что сами операторы определяют области видимости имён,
из всего этого следует, что блочная структура, в некотором роде, имеет место быть.
В <a href="ofp-scripting.variable.html#contexts">главе о переменных</a> мы
узнаем о некоторых следствиях связанных с этой особенностью.</p>
<h5 id="toc16">Передача и получение аргументов функций</h5>

<p>Передача и получение аргументов sqf функций полностью аналогичны тому как это делается в sqs.
Например, функция принимающая скаляр может просто манипулировать предопределенной
переменной _this, содержащей переданное значение:</p>
<pre class="hl">_stupid_hint <b>= {
    _this =</b> <i>"Hint: "</i> <b>+ _this</b>;
    <u>hint</u> <b>_this
}</b></pre>

<p>Вызов с передачей аргумента выглядит так:</p>
<pre class="hl"><i>"Stupid example"</i> <b>call</b> _stupid_hint</pre>

<p>Если передается несколько значений, то также, как и в случае с sqs используется массив:</p>
<pre class="hl">_hint_two_strings <b>= {</b>
    <u>hint</u> <b>(
            ( _this select</b> 0 <b>) +</b> <i>"\n"</i> <b>+
            ( _this select</b> 1 <b>)
         )
}</b></pre>

<p>Вызов с передачей нескольких аргументов будет выглядеть так:</p>
<pre class="hl"><b>[</b><i>"Hello,"</i><b>,</b> <i>"Word!"</i><b>] call</b> _hint_two_strings</pre>

<p>Для более удобной работы с аргументами, часто имеет смысл записать их в переменные:</p>
<pre class="hl">_my_sqf_function <b>= {

    private[</b><i>"_arg0"</i><b>,</b> <i>"_arg1"</i><b>,</b> <i>"_arg2"</i><b>]</b>;

    _arg0 <b>= _this select</b> 0;
    _arg1 <b>= _this select</b> 1;
    _arg2 <b>= _this select</b> 2;

<b>}</b></pre>

<p>Здесь все аналогично случаю с sqs, за одним небольшим отличием — поскольку в одном файле может быть описано несколько функций,
то должна решаться проблема пространств имён. Этот момент более подробно рассмотрен
<a href="ofp-scripting.variable.html#NameSpaces">в главе о переменных</a>, а пока мы просто скажем, что все
переменные sqf функций должны быть указаны <i>приватными</i> (т.е. принадлежащими текущему контексту) командой private, как это показано в примере выше.</p>

<p>Ну и наконец, отметим, что если мы не хотим передавать аргументы,
то можем этого не делать — у call в отличии от exec может отсутствовать левый операнд.</p>

<p><span tooltip="Эти детали при первом прочтении можно опустить">Некоторые тонкости</span>.</p>

<p>Нужно также осветить один момент относительно автоматической переменной _this —
эта переменная будет присутствовать лишь в том случае, когда вы передавали в функцию аргумент,
поэтому будьте внимательны, переписывая её значение:</p>
<pre class="hl"><i>"origin value"</i> <b>call {</b>
    <i>"anything"</i> <b>call { _this =</b> <i>"new value"</i> <b>}</b>;
    <u>hint</u> <b>_this</b> <s>// печатает "origin value"</s>
<b>}</b></pre>

<p>Здесь все верно, вложенная функция переписывает собственный _this,
но следующий пример показывает  возможную ошибку:</p>
<pre class="hl"><i>"origin value"</i> <b>call {
    call { _this =</b> <i>"new value"</i> <b>}</b>;
    <u>hint</u> <b>_this</b> <s>// печатает "new value"</s>
<b>}</b></pre>

<p>Так как вложенная функция не получила аргумента, то для нее, соответственно,
не была создана переменная _this, поэтому присваивание «_this = "new value"»
перепишет родительский _this.</p>
<h5 id="toc17">Возвращаемое значение</h5>

<p>Функции называются так не случайно, от простых подпрограмм их
отличает то, что они способны возвращать значение.
Вспомним, что sqf функции в данном языке возвращают последнее вычисленное выражение,
например такая функция возвращает количество гранатометчиков в переданной группе:</p>
<pre class="hl">_count_grenadiers <b>= {
    {</b>
        <i>""</i> <b>!=</b> <u>secondaryWeapon</u> _x
    <b>}</b> <u>count units</u> <b>_this
}</b></pre>

<p>Эта функция состоит из одного выражения, результат его вычисления и будет возвращен вызывающей стороне:</p>
<pre class="hl"><u>hint format</u> <b>[</b><i>"%1"</i><b>,</b> <u>player</u> <b>call</b> _count_grenadiers<b>]</b></pre>

<p>Заметьте, что в конце тела функции не надо ставить точку с запятой, иначе последним выражением
будет считаться то, что идет после «;», т.е. ничего. В качестве иллюстрации, вызов</p>
<pre class="hl text"><b>call {</b> 10 <b>}</b></pre>

<p>вернёт число 10, в отличии от вызова</p>
<pre class="hl text"><b>call {</b> 10; <b>}</b></pre>

<p>который возвращает Nothing.
Если функция заканчивается одной из веток ветвления «if then else»,
то точка с запятой должна отсутствовать не только после ветвления, <span tooltip="Почему такое вообже возможно, что функция возвращает значение в данном примере мы узнаем из рассказа о «if then else»">но и в обеих ветках</span>:</p>
<pre class="hl">_max <b>= {
    if ( _this select</b> 0 <b>&gt;= _this select</b> 1 <b>) then {
        _this select</b> 0
    <b>} else {
        _this select</b> 1
    <b>}
}</b></pre>

<p><i>Примечание: в общем случае, точка с запятой не обязана стоять после каждого выражения —
этот символ отделяет одно выражение от другого, а не является признаком его конца,
как в некоторых других языках.</i></p>

<p>Очевидный момент, но все же отметим его: одиночно стоящая константа, переменная либо команда, также
являются выражением и соответственно вычисляется:</p>
<pre class="hl"><s>// возвращает все оружие группы одним массивом:</s>
_get_group_weapons <b>= {
    private</b> <i>"_w"</i>;
    _w <b>= []</b>;
    <b>{</b>
        _w <b>=</b> _w <b>+</b> <u>weapons</u> <b>_this
    } foreach (</b> <u>units</u> <b>_this )</b>;
    _w <s>// &lt;- это выражение будет вычисленно и его результат возвращен</s>
<b>}</b></pre>

<p>Естественно, что мы можем использовать sqf функции так же, как используем команды
возвращающие значение — вызывая их непосредственно из выражений:</p>
<pre class="hl">_small_arms <b>=</b> <u>count</u> <b>( (</b> <u>player</u> <b>call</b> _get_group_weapons <b>) - [</b><i>"Binocular"</i><b>,</b> <i>"NVGoggles"</i><b>] )
               - (</b> <u>player</u> <b>call</b> _count_grenadiers <b>)</b>;</pre>

<p>Теперь _small_arms содержит количество единиц стрелкового оружия отделения игрока.</p>
<h5 id="toc18">Комментарии</h5>

<p>Мы уже неоднократно использовали в приводимых примерах строчные комментарии,
как несложно было заметить, символом такого комментария является двойной слэш «//» —
все, что идет после него до конца строки может быть произвольным текстом, и будет
игнорироваться интерпретатором.</p>
<pre class="hl"><s>// Это строчный комментарий</s>
<u>hint</u> <i>"подсказка"</i> <s>// перед комментарием может располагаться код </s></pre>
Если ваш комментарий занимает несколько строк, или вы хотите
временно отключить часть кода, то удобно воспользоваться многострочным комментарием —
для этого заключите текст между открывающим «/*» и
закрывающим «*/» символами, так как это сделано в примере:
<pre class="hl"><s>/*
    Это
    многострочный
    комментарий
*/</s></pre>
Надо отметить, что комментарии (как и макро) обеспечиваются работой команды preprocessFile,
и справедливы только для файлов подключаемых этой командой.
<h5 id="toc19">Макро</h5>

<p>Препроцессинг, осуществляемый командой preprocessFile, позволяет использовать,
помимо комментариев, <i>макроподстановку</i>.
Макроподстановка — это механизм замены символического имени на произвольный текст.
Макро определяется директивой препроцессора #define, создадим для примера макро MY_SOLDIERS:</p>
<pre class="hl"><u>#define MY_SOLDIERS (units player) </u></pre>

<p>теперь в файле обрабатываемом preprocessFile все вхождения имени MY_SOLDIERS будут заменены
на (units player). Можно создавать многострочные макро используя символ
переноса на следующую строку «\».</p>

<p>Макро может принимать параметры:</p>
<pre class="hl"><u>#define SOLDIERS(G) (units G) </u></pre>

<p>Теперь можно использовать «SOLDIERS(player)» для получения массива юнитов группы игрока.</p>

<p>Макро особенно удобно использовать для доступа к элементам массивов.
Допустим мы не хотим создавать лишние переменные для доступа к аргументам функции:</p>
<pre class="hl"><u>#define ARG0 (_this select 0)
#define ARG1 (_this select 1)
#define ARG2 (_this select 2) </u></pre>

<p>Здесь, как видим, используются «бессмысленные» имена макро, на деле они,
конечно, будут отражать предназначение аргументов.</p>

<p>Или еще одна область применения — язык, к сожалению, не поддерживает
пользовательские типы данных, поэтому вместо структур С или записей Паскаля,
приходится использовать массивы. Самая большая неприятность здесь заключается в том,
что надо помнить по какому смещению в массиве находится то или иное поле,
а в случае изменения порядка в котором они следуют придется переписывать весь код,
где происходит обращение к этим массивам.
Конечно, макро может очень помочь в этой ситуации, ради примера посмотрим как могли бы
выглядеть макроопределения для доступа к полям гипотетической структуры хранящей данные о юнитах:</p>
<pre class="hl"><s>// макро чтения</s>
<u>#define mGetVehicleType(s)    ((s) select 0)
#define mGetPosition(s)       ((s) select 1)
#define mGetIdentityHandle(s) ((s) select 2)
#define mGetStatusHandle(s)   ((s) select 3)
#define mGetAzimut(s)         ((s) select 4)
#define mGetSkill(s)          ((s) select 5)
#define mGetRank(s)           ((s) select 6)</u>

<s>// макро модификации</s>
<u>#define mSetVehicleType(s,v)    ((s) set[0,v])
#define mSetPosition(s,v)       ((s) set[1,v])
#define mSetIdentityHandle(s,v) ((s) set[2,v])
#define mSetStatusHandle(s,v)   ((s) set[3,v])
#define mSetAzimut(s,v)         ((s) set[4,v])
#define mSetSkill(s,v)          ((s) set[5,v])
#define mSetRank(s,v)           ((s) set[6,v]) </u></pre>

<p>Областью действия макро является текст sqf скрипта, от точки определения макро, до конца файла.</p>

<p>Пару слов скажем о именах макро. В языках чувствительных к регистру символов
принято давать имена макро в верхнем регистре, это позволяет не беспокоится о случайном
совпадении имени переменной с именем макро, а также делает их легко узнаваемыми.
Однако наш интерпретатор игнорирует регистр, поэтому такой подход не будет иметь смысла —
единственное, что можно порекомендовать, это использование «специального» префикса, например «mcr_».</p>
<h5 id="toc20">Операторы управления процессом вычисления</h5>

<p>Вот мы и добрались непосредственно до операторов управления потоком.
Как мы уже отметили их не так много: ветвление «if then else» и цикл «while do»,
а также старенький, но от этого не менее полезный «foreach».
Такие вещи как например «switch» не поддерживаются, но мы покажем как можно их имитировать.</p>
<h6 id="toc21">Оператор условного выполнения if then else</h6>

<p>Этот составной оператор позволяет выполнить тот или иной код в зависимости от условия.
Синтаксис оператора:</p>
<pre class="hl"><b>if (</b> «condition» <b>) then {</b>
    «then_expression»
<b>} else {</b>
    «else_expression»
<b>}</b></pre>

<p>Часть «else» необязательна, и если она не нужна, то все сокращается до следующего:</p>
<pre class="hl"><b>if (</b> «condition» <b>) then {</b>
    «then_expression»
<b>}</b></pre>

<p>Здесь:</p>
<table class="list">
<tbody>
<tr><th>«condition»</th><th>—</th><td>условие</td></tr>
<tr><th>«then_expression»</th><th>—</th><td>код который будет выполнен, если «condition» истинно</td></tr>
<tr><th>«else_expression»</th><th>—</th><td>код который будет выполнен, если «condition» ложно</td></tr>
</tbody>
</table>

<p>Подробнее скажем о условии — условием является
любое выражение языка возвращающее булево (логическое) значение.
Всего существует два таких значения — true (истина) и false (ложь),
например утверждение «<tt>A &gt; B</tt>»
будет истинно (и соответственно вернёт true) если <tt>A</tt> действительно больше <tt>B</tt>,
в противном случае утверждение ложно (и возвращает false).</p>

<p>О булевом типе можно более подробно прочитать <a href="ofp-scripting.variable.html#toc05">
в главе о переменных</a>, а пока отметим
лишь, что значения с таким типом возвращают некоторые команды, например
<span tooltip="Вернёт true если объект передаваемый правым операндом жив;
на предмет других команд возвращающих boolean смотрим комреф">alive</span>,
<span tooltip="Вернёт true если объект может стрелять;
на предмет других команд возвращающих boolean смотрим комреф">canFire</span>,
<span tooltip="Вернёт true если объект может передвигаться;
на предмет других команд возвращающих boolean смотрим комреф">canMove</span>,
<span tooltip="Вернёт true если солдат сбегает с поля боя;
на предмет других команд возвращающих boolean смотрим комреф">fleeing</span>,
<span tooltip="Вернёт true если солдат пленен;
на предмет других команд возвращающих boolean смотрим комреф">captive</span>, оператор
<span tooltip="Вернёт true если в массиве указанном правым операндом есть элемент равный левому операнду;
и все равно смотрите комреф, нефига фсе в подсказки смотреть )) ">in</span>
и <i>операторы отношения</i>:</p>

<table class="list">
<tbody>
<tr><th>&gt;</th><th>—</th><th><i>истина</i>, если левый операнд больше правого, иначе <i>ложь</i></th></tr>
<tr><th>&lt;</th><th>—</th><th><i>истина</i>, если левый операнд меньше правого, иначе <i>ложь</i></th></tr>
<tr><th>&gt;=</th><th>—</th><th><i>истина</i>, если левый операнд больше правого или равен ему, иначе <i>ложь</i></th></tr>
<tr><th>&lt;=</th><th>—</th><th><i>истина</i>, если левый операнд меньше правого или равен ему, иначе <i>ложь</i></th></tr>
<tr><th>==</th><th>—</th><th><i>истина</i>, если левый операнд равен правому, иначе <i>ложь</i></th></tr>
<tr><th>!=</th><th>—</th><th><i>истина</i>, если левый операнд не равен правому, иначе <i>ложь</i></th></tr>
</tbody>
</table>

<p>Над значениями булевого типа можно совершать следующие логические операции <i>(слева дан си-подобный вариант синтаксиса,
справа в скобках — синтаксис которым могут воспользоваться сторонники паскаля)</i>:</p>
<table class="list">
<tbody>
<tr><th>&amp;&amp;  (and)</th><th>—</th><th>логичекое «<tt>И</tt>», <i>истина</i>, если оба операнда истина, иначе ложь</th></tr>
<tr><th>||  (or)</th><th>—</th><th>логичекое «<tt>ИЛИ</tt>», <i>истина</i>, если хотя бы один из операндов истина, иначе ложь</th></tr>
<tr><th>!   (not)</th><th>—</th><th>логичекое «<tt>НЕ</tt>», <i>истина</i>, если операнд ложь, иначе ложь</th></tr>
</tbody>
</table>

<p>Эти операторы, также, возвращают значения с типом Boolean.</p>

<p>Допустим есть выражение « <tt>A &gt; B &amp;&amp; C == D</tt> » (читается как «A больше B и C равно D»),
где A, B, C и D — числа (величины с типом Number),
тогда « <tt>A &gt; B</tt> » и « <tt>C == D</tt> » будут подвыражениями с типом Boolean,
(операторы больше «&gt;» и равно «==» возвращают Boolean), и
одновременно операндами логического «<tt>И</tt>» (<tt>&amp;&amp;</tt>); соответственно типом
возвращаемого значения нашего выражения будет тип возвращаемый оператором «<tt>И</tt>» (<tt>&amp;&amp;</tt>) — Boolean.</p>

<p>Создавая, таким образом, подвыражения булевого типа,
и совершая логические операции над ними мы получаем новые булевые [под]выражения;
продолжая этот процесс рекурсивно мы можем конструировать утверждения любой сложности.</p>
<p id="AboutIfThenElse"><span tooltip="Лучше пропустите эти подробности, если читаете первый раз">Некоторые тонкости</span>.</p>

<p><i>Примечание: эти интересные детали лучше пропустить при первом прочтении.</i></p>

<p>Замечательной особенностью оператора «if then else» рассматриваемого языка, является то, что он может возвращать значение.
Например:</p>
<pre class="hl">_n <b>=</b> <em>true</em>;
<u>hint</u> <b>( if (</b> _n <b>) then {</b> <i>"1"</i> <b>} else {</b> <i>"2"</i> <b>} )</b></pre>

<p>щелкнет хинтом "1", или хинтом "2", если изменить _n на false.</p>

<p>Чтобы понять почему так происходит, давайте заглянем в comref и посмотрим,
что представляют собой команды if, then и else.
Ок, теперь нам понятно, что виновником такого поведения является команда then —
именно она возвращает, в нашем случае, строчку "1";
при этом значение, возвращаемое командой if станет левым операндом then, а массив,
возвращаемый командой else — правым операндом.
Расставим, для наглядности, скобки:</p>
<pre class="hl"><b>( if (</b> _n <b>) ) then ( {</b> <i>"1"</i> <b>} else {</b> <i>"2"</i> <b>} )</b></pre>

<p>Непривычно, но такая запись совершенно корректна для данного языка.</p>

<p>Итак, мы видим, что команда else фактически возвращает массив с двумя строковыми величинами,
а then, в зависимости от состояния своего левого операнда (он имеет специальный тип "IF") выполняет или нулевой,
или первый элемент этого массива. Это легко проверяется такими примерами:</p>
<pre class="hl">_n <b>=</b> <em>true</em>;
<b>if (</b> _n <b>)then[{</b> <u>hint</u> <i>"1"</i> <b>}, {</b> <u>hint</u> <i>"2"</i> <b>}]</b></pre>
<pre class="hl"><u>hint</u> <b>( {</b><i>"Alpha"</i><b>} else {</b><i>"Beta"</i><b>} select</b> 0 <b>)</b></pre>
<pre class="hl"><u>hint</u> <b>( {</b><i>"Alpha"</i><b>} else {</b><i>"Beta"</i><b>} select</b> 1 <b>)</b></pre>

<p>Здесь же уместно вспомнить, что команда select имея правым операндом булево значение возвращает
<del>или первый, или нулевой элемент</del>один из двух элементов своего левого операнда-массива:</p>
<pre class="hl">_n <b>=</b> <em>true</em>;
<u>hint</u> <b>( {</b>1<b>} else {</b>2<b>} select</b> _n <b>)</b></pre>

<p>Вот так забавно разработчики реализовали, вполне привычные, на первый взгляд, вещи.</p>
<pre class="hl">_A <b>=</b> 1;
_B <b>=</b> 2;
_cond <b>= if (</b> _A <b>&lt;</b> _B <b>)</b>;
_case <b>= [
    {</b> <u>hint</u> <i>"_A &lt; _B"</i> <b>},
    {</b> <u>hint</u> <i>"_B &lt; _A"</i> <b>}
]</b>;
_cond <b>then</b> _case</pre>

<p>Теперь мы знаем какое безобразие прячется за маской благопристойности свойственной
классическим языкам, скрывая от нас свою порочную природу :-).
Цикл «while do», рассматриваемый далее, препарируется столь же легко, займитесь им на досуге самостоятельно.</p>
<h6 id="toc22">Оператор цикла while do</h6>

<p>Составной оператор «<tt>while do</tt>» реализует цикл, тело
которого повторяется до тех пор пока условие в части «while» истинно:</p>
<pre class="hl"><b>while {</b> «condition» <b>} do {</b>
    «loop_body»
<b>}</b></pre>

<p>Тело цикла <i>«loop_body»</i> будет выполняться пока истинно условие <i>«condition»</i>.
Заметьте, что условие в части «while» заключается в фигурные (т.е. это обычная анонимная sqf-функция), а не
круглые (как условие в «if») скобки, будьте внимательны.</p>

<p>Например, запишем цикл со счетчиком:</p>
<pre class="hl"><b>private</b> <i>"_counter"</i>;

_counter <b>=</b> 0;

<b>while {</b> _counter <b>!=</b> 20 <b>} do {</b>

    <s>// ваши действия</s>
    _counter <b>=</b> _counter <b>+</b> 1

<b>}</b></pre>

<p>Так организуется прямой обход массива:</p>
<pre class="hl"><b>private</b> <i>"_index"</i>;

_index <b>=</b> 0;

<b>while {</b> _index <b>&lt;</b> <u>count</u> _array <b>} do {</b>

    <s>// некоторые действия над текущим элементом
    // массива (_array select _index)</s>

    _index <b>=</b> _index <b>+</b> 1

<b>}</b></pre>

<p>А так обратный:</p>
<pre class="hl"><b>private</b> <i>"_index"</i>;

_index <b>=</b> <u>count</u> _array;

<b>while {</b> _index <b>&gt;</b> 0 <b>} do {</b>

    _index <b>=</b> _index <b>-</b> 1

    <s>// некоторые действия над текущим элементом
    // массива (_array select _index)</s>

<b>}</b></pre>

<p>Цикл типа «do while», как правило, используются реже чем «while do», но если вдруг вам он понадобился,
то можно вынести проверку в конец таким образом:</p>
<pre class="hl"><b>private</b> <i>"_condition"</i>;

_condition <b>=</b> <em>true</em>;

<b>while {</b> _condition <b>} do {</b>
    «тело цикла»
    _condition <b>=</b> «настоящее условие»
<b>}</b></pre>

<p>Язык не поддерживает операторы break и continue, вы не можете выйти в любой момент из цикла
или начать новую итерацию, поэтому используйте
возможности <nobr>«if .. then .. else»</nobr> совместно с дополнительной
переменной — флагом «break»:</p>
<pre class="hl">break <b>=</b> <em>false</em>;
<b>while {</b> _real_condition_ <b>&amp;&amp; !</b>break <b>} do {</b>

    <s>// если необходимо прервать цикл</s>
    <b>if (</b> условие <b>){</b>
        break <b>=</b> <em>true</em>
    <b>} else {</b>
        <s>// продолжение цикла

        // если необходимо перейти в начало цикла</s>
        <b>if ( !</b> условие <b>){</b>
            <s>// продолжение цикла</s>
        <b>}
    }
}</b></pre>

<p>Цикл while не может выполняться бесконечно, и если количество итераций превысит 10000, то интерпретатор
остановит работу скрипта и выдаст ошибку.</p>
<h6 id="toc23">Оператор поэлементного обхода массива foreach</h6>

<p>Часто встречающейся задачей является выполнение некоторых действий над всеми элементами массива.
Удобным решением может быть цикл foreach, например, предыдущий пример обхода массива с «while»
мог быть записан так:</p>
<pre class="hl"><b>{</b>
    <s>// некоторые действия над текущим элементом
    // массива (автоматическая переменная _x)</s>
<b>} foreach</b> _array</pre>

<p>Как видим код может быть короче и лаконичнее,
в примере мы обошлись без указателя текущего элемента («_index»),
вместо этого используется зарезервированная переменная «_x» —
на каждой итерации цикла она автоматически принимает значение текущего элемента массива.</p>

<p>Следующий пример восстановит здоровье всех членов отряда игрока:</p>
<pre class="hl"><b>{</b>
    _x <u>setDammage</u> 0
<b>} foreach</b> <u>units player</u></pre>

<p>Интересной особенностью foreach является то, что мы можем в ходе цикла менять сам
обрабатываемый массив, например удалить некоторые его элементы (изменив тем самым размер массива),
и интерпретатор это корректно учтёт.</p>

<p>Однако не всегда выбор надо делать в пользу foreach.
Например, если нужен параллельный обход сразу двух массивов, то мы все равно не обойдемся без
указателя текущего элемента (_index в примере с «while»), также
если нужна возможность досрочно прекратить обход (например при поиске перебором), то «while»
тоже будет правильным выбором.</p>
<h6 id="toc24">Косвенный вызов функций или имитирование оператора switch</h6>

<p><i>Примечание: эта часть несколько сложнее остальных, поэтому при первом чтении её можно пропустить.</i></p>

<p>Самый простой вариант switch может быть осуществлен лишь
для ключей удовлетворяющим следующим условиям:
они должны быть целыми числами, подряд следующими друг за другом без пропусков (как 4, 5, 6, 7, 8, 9 и т.д.),
тогда мы используем массив содержащий анонимные функции, а ключ будем использовать как индекс этого массива:</p>
<pre class="hl"><s>// привести ключ к нужному диапазону</s>
_key <b>= _this -</b> 4;

<s>// таблица анонимных функций</s>
_switch <b>= [
    {</b> <u>hint</u> <i>"4"</i> <b>},
    {</b> <u>hint</u> <i>"5"</i> <b>},
    {</b> <u>hint</u> <i>"6"</i> <b>},
    {</b> <u>hint</u> <i>"7"</i> <b>},
    {</b> <u>hint</u> <i>"8"</i> <b>},
    {</b> <u>hint</u> <i>"9"</i> <b>}
]</b>;

<s>// если индекс укладывается в границы массива — вызвать нужную функцию</s>
<b>if (</b> _key <b>&gt;=</b> 0 <b>&amp;&amp;</b> _key <b>&lt;</b> <u>count</u> _switch <b>) then {
    call (</b>_switch <b>select</b> _key<b>)
}</b></pre>

<p>Это конечно здорово, но как быть если наши ключи строковые? Здесь тоже есть варианты.</p>

<p>Если строковое значение по которому надо сделать выбор не содержит пробелов и в целом
удовлетворяет требованиям к именам (см. главу <a href="ofp-scripting.variable.html#variableNames">Переменные</a>),
то можно использовать ключ как имя функции:</p>
<pre class="hl"><b>private</b> <i>"_switches"</i>;

<s>// имена функций для наших ключей</s>
_switches <b>= [</b>
    <i>"_key_MY_VALUE1"</i><b>,</b>
    <i>"_key_MY_VALUE2"</i><b>,</b>
    <i>"_key_MY_VALUE3"</i>
<b>]</b>;

<s>// если для ключа имеется действие (в _this ожидается ключ)</s>
<b>if (</b> <i>"_key_"</i> <b>+ _this in</b> _switches <b>) then {</b>

    <s>// объявить имена функций принадлежащими текущему контексту блока then</s>
    <b>private</b> _switches;

    <s>// сами действия</s>
    _key_MY_VALUE1 <b>= {</b> <u>hint</u> <i>"MY VALUE 1"</i> <b>}</b>;
    _key_MY_VALUE2 <b>= {</b> <u>hint</u> <i>"MY VALUE 2"</i> <b>}</b>;
    _key_MY_VALUE3 <b>= {</b> <u>hint</u> <i>"MY VALUE 3"</i> <b>}</b>;

    <s>// косвенный вызов</s>
    <b>call (call (</b><i>" _key_"</i> <b>+ _this))</b>;

<b>} else {</b>
    <s>// если для ключа не нашлось действия</s>
    <u>hint</u> <b>(</b> <i>"not found: """</i> <b>+ _this +</b> <i>""""</i><b>)
}</b></pre>

<p>Можно запустить этот пример так:<br> « <tt>"MY_VALUE2" call preprocessFile "этот пример помещенный в файл.sqf"</tt> »</p>

<p>В плане оптимизации можно убрать проверку « "_key_" + _this in _switches ».
В этом варианте мы лишаемся действия по умолчанию (если нужный ключ не нашелся), в остальном все остается так же:</p>
<pre class="hl"><b>private</b> <i>"_key_name"</i>;

_key_name <b>=</b> <i>"_key_"</i> <b>+ _this</b>;

<s>// предохранимся, на случай если в текущем контексте
// вдруг окажется переменная с тем же именем</s>
<b>private</b> _key_name;

<s>// имена функций</s>
<b>private [</b>
    <i>"_key_MY_VALUE1"</i><b>,</b>
    <i>"_key_MY_VALUE2"</i><b>,</b>
    <i>"_key_MY_VALUE3"</i>
<b>]</b>;

<s>// сами действия</s>
_key_MY_VALUE1 <b>= {</b> <u>hint</u> <i>"MY VALUE 1"</i> <b>}</b>;
_key_MY_VALUE2 <b>= {</b> <u>hint</u> <i>"MY VALUE 2"</i> <b>}</b>;
_key_MY_VALUE3 <b>= {</b> <u>hint</u> <i>"MY VALUE 3"</i> <b>}</b>;

<s>// косвенный вызов</s>
<b>call (call</b> _key_name<b>)</b>;</pre>

<p>Последний, самый сложный вариант — выбор по ключу являющимся свободной строкой.
В этом случае никакие особенности языка нам не помощники, и придется реализовывать поиск в массиве пар.</p>
<pre class="hl"><b>private[</b><i>"_pairs"</i><b>,</b> <i>"_findValueInPairs"</i><b>]</b>;

<s>// массив пар: ключ/функция</s>
_pairs <b>= [</b>
    <i>"- key 1 -"</i><b>, {</b> <u>hint</u> <i>"Key 1"</i> <b>},</b>
    <i>"- key 2 -"</i><b>, {</b> <u>hint</u> <i>"Key 2"</i> <b>},</b>
    <i>"- key 3 -"</i><b>, {</b> <u>hint</u> <i>"Key 3"</i> <b>}
]</b>;

<s>// ищет прямым перебором ключ и возвращает сопоставленное ему значение</s>
_findValueInPairs <b>= {

    private[</b><i>"_a"</i><b>,</b> <i>"_k"</i><b>,</b> <i>"_i"</i><b>]</b>;

    _a <b>= _this select</b> 0; <s>// массив пар</s>
    _k <b>= _this select</b> 1; <s>// искомый ключ</s>
    _i <b>=</b> 0;

    <s>/*
        пока (
            (не вышли за границы массива) и
            (не нашли искомое значение)
        ) —&gt; продолжать поиск
    */</s>
    <b>while {
        if (</b> _i <b>&lt;</b> <u>count</u> _a <b>) then {</b> _a <b>select</b> _i <b>!=</b> _k <b>} else {</b> <em>false</em> <b>}
    } do {</b>
        _i <b>=</b> _i <b>+</b> 2
    <b>}</b>;

    <s>/*
        если в процессе поиска мы не вышли за границы массива
            ключ был найден, вернуть ассоциированную с ним функцию
        иначе
            вернуть анонимную функцию выводящую сообщение о неудаче
    */</s>
    <b>if (</b> _i <b>&lt;</b> <u>count</u> _a <b>)then[{</b>_a <b>select (</b>_i <b>+</b> 1<b>)}, {{</b><u>hint</u> <i>"not found"</i><b>}}]

}</b>;

<b>call ([</b>_pairs<b>, _this] call</b> _findValueInPairs<b>)</b>;</pre>

<p>Увы, нам приходится использовать прямой перебор; поскольку язык не позволяет использовать
операторы «больше» и «меньше» со строками, мы не можем оптимизировать сам
подход используя древовидное иерархическое хранение данных.</p>

<p>Обратите внимание на то как написано условие для while — вместо более очевидного:</p>
<pre class="hl text">_i <b>&lt;</b> <u>count</u> _a <b>&amp;&amp;</b> _a <b>select</b> _i <b>!=</b> _k</pre>

<p>используется возвращающий значение «if then else», объяснение здесь простое —
скрипт-интерпретатор в игре, в отличии от подавляющего большинства языков, всегда вычисляет все условие
полностью и мы можем вылететь за границы массива, порадовав игрока сообщением об ошибке (<a href="ofp-scripting.variable.html#stupidSQF&amp;SQS&amp;BIS&amp;ETC">комментарий</a>)</p>

<p>Кстати, наше условие можно упростить, убрав часть else:</p>
<pre class="hl text"><b>if (</b> _i <b>&lt;</b> <u>count</u> _a <b>) then {</b> _a <b>select</b> _i <b>!=</b> _k <b>}</b></pre>

<p>Поясним: если условие « <tt>_i &lt; count _a</tt> » не будет выполнено,
то команда «then» вернёт неопределенную величину, что прекратит работу цикла.</p>

<p><i>Примечание: более того, while, в действительности, может принимать не
только булево значение, но справедливым будет считаться лишь случай когда выражение вернуло true.</i></p>

<p>И конечно, этот пример слишком сложен для простого switch (если вы не собираетесь делать выбор из сотен вариантов), и скорее подходит для хранения связанных данных.</p>

<p><i>Примечание. В примерах использовано всего несколько пар ключ/функция; если их немного, конечно, лучше использовать вложенные «if then else»
и лишь когда их более одного десятка, следует прибегать о описанным методам.
Кроме того (и ради этого, в основном, я рассказал о них) все эти примеры показывают как могут
быть реализованы в sqf структуры данных ключ/значение.</i></p>
<h5 id="toc25">Рекурсивные функции</h5>

<p>Язык «некоторым образом» поддерживает рекурсию. «Некоторым образом» —
потому, что глубина рекурсии очень невелика, и если ваша функция «нырнет» глубже положенного,
то игра, банально, вылетит. Вот пример простой тестовой рекурсивной функции:</p>
<pre class="hl">_str <b>=</b> <i>""</i>;

_recurse_test <b>= {
    if ( _this &lt;</b> 29 <b>) then {</b>
        _str <b>=</b> _str <b>+</b> <u>format</u> <b>[</b><i>"[%1]-&gt; "</i><b>, _this]</b>;
        <b>_this+</b>1 <b>call</b> _recurse_test;
        _str <b>=</b> _str <b>+</b> <u>format</u> <b>[</b><i>" &lt;-[%1]"</i><b>, _this]</b>;
    <b>}
}</b>;

0 <b>call</b> _recurse_test;

<u>hint</u> _str;</pre>

<p>На двух разных машинах экспериментально выяснено, что максимальная глубина равна
29 рекурсивным вызовам. Однако не стоит сильно доверять этой цифре, поэтому всегда проверяйте текущую глубину,
и прекращайте работу своего скрипта если глубина слишком большая.</p>

<p>Конечно, это рисковано, и лучше обходится совсем без рекурсии, но иногда это очень помогает,
например при написании прототипа скрипта, как в примере обхода дерева:</p>
<pre class="hl">_plain <b>= []</b>;
_push <b>= {</b> _plain <u>set</u> <b>[</b><u>count</u> _plain<b>, _this] }</b>;

<s>// разворачивает дерево</s>
_unwrapTree <b>= {
    if ( _this in [_this] ) then {</b> <s>// если не массив - вывести элемент в поток</s>
        <b>_this call</b> _push
    <b>} else {</b>                      <s>// если массив -</s>
        <i>"&lt;array&gt;"</i> <b>call</b> _push;                   <s>// обозначить это дело</s>
        <b>{</b> _x <b>call</b> _unwrapTree <b>} foreach _this</b>;  <s>// и повторить процедуру для каждого его элемента</s>
        <i>"&lt;/array&gt;"</i> <b>call</b> _push;
    <b>}</b>;
<b>}</b>;

<b>[</b>
    1<b>,</b> 2<b>,</b> <i>"some string"</i><b>,
    [</b><i>"A"</i><b>,</b><i>"B"</i><b>,</b><i>"C"</i><b>],</b>
    <u>magazines player</u><b>,
    [
        [</b><i>"r1c1"</i><b>,</b><i>"r1c2"</i><b>,</b><i>"r1c3"</i><b>,</b><i>"r1c4"</i><b>,</b><i>"r1c5"</i><b>],
        [</b><i>"r2c1"</i><b>,</b><i>"r2c2"</i><b>,</b><i>"r2c3"</i><b>,</b><i>"r2c4"</i><b>,</b><i>"r2c5"</i><b>],
        [</b><i>"r3c1"</i><b>,</b><i>"r3c2"</i><b>,</b><i>"r3c3"</i><b>,</b><i>"r3c4"</i><b>,</b><i>"r3c5"</i><b>]
    ]

] call</b> _unwrapTree;

_plain</pre>

<p>Уже после того как вы отладили прототип, можно ради безопасности переписать такие подпрограммы на стек.</p>

</body>
</html>
