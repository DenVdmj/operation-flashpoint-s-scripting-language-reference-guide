<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Язык описания сценариев игры Operation Flashpoint. Справочное руководство. Синтаксис языка.</title>
<link href=".rsc/style.css" rel="stylesheet" type="text/css" />
<script src=".rsc/highlight.pack.js"></script>
<script src=".rsc/init.js"></script>
<script src="hyphened-text.js"></script>
</head>
<body>

<ul class="toc">
<li><a href="#toc00">Синтаксис языка</a>
    <ul>
    <li><a href="#toc01">Sqs скрипты</a>
    <ul>
        <li><a href="#toc02">Выполнение sqs скриптов</a></li>
        <li><a href="#toc03">Построковая структура sqs скрипта</a></li>
        <li><a href="#toc04">Передача и получение аргументов скрипта</a></li>
        <li><a href="#toc05">Комментарии</a></li>
        <li><a href="#toc06">Операторы управления процессом вычисления</a><ul>
            <li><a href="#toc07">Оператор условного выполнения ?:</a></li>
            <li><a href="#toc08">Метки и оператор goto</a></li>
            <li><a href="#toc09">Ожидание выполнения указанного условия @</a></li>
            <li><a href="#toc10">Ожидание наступления указанного времени &amp;</a></li>
            <li><a href="#toc11">Пауза ~</a></li>
            <li><a href="#toc12">Выход из скрипта</a></li>
        </ul>
        </li>
    </ul>
    </li>
    <li><a href="#toc13">Sqf функции
    </a><ul>
        <li><a href="#toc14">Выполнение sqf функций</a></li>
        <li><a href="#toc15">Блочная структура функций</a></li>
        <li><a href="#toc16">Передача и получение аргументов функций</a></li>
        <li><a href="#toc17">Возвращаемое значение</a></li>
        <li><a href="#toc18">Комментарии</a></li>
        <li><a href="#toc19">Макро</a></li>
        <li><a href="#toc20">Операторы управления процессом вычисления
        </a><ul>
            <li><a href="#toc21">Оператор условного выполнения if then else</a></li>
            <li><a href="#toc22">Оператор цикла while do</a></li>
            <li><a href="#toc23">Оператор поэлементного обхода массива foreach</a></li>
            <li><a href="#toc24">Косвенный вызов функций или имитирование оператора switch</a></li>
        </ul>
        </li><li><a href="#toc25">Рекурсивные функции</a></li>

    </ul>
    </li>
</ul>
</li>
</ul>

<h3 id="toc00">Синтаксис языка</h3>

<p>Код, записанный на скриптовом языке, состоит из команд и их операндов. Несмотря на то, что в оригинальном
комрефе разработчики игры не делят команды на операторы, функции, ключевые слова и т.д. мы будем
<span tooltip="Это типа отмазка такая, почему я тут назвал это так, а в другом месте подругому. Пишу как умею :-)">иногда</span>
проводить такое деление. Например, команды математических операций и команды управления выполнением будут часто называться операторами,
а команды возвращающие значение — функциями (как, например, математические функции), хотя иногда я буду забывать об этом и называть их просто командами.</p>

<p>Некоторые команды могут возвращать значение, самой близкой аналогией здесь может быть пример из математики: мы говорим, что функция sin
возвращает синус аргумента. Аналогично и в языках программирования — запись <tt>sin(x)</tt> вернёт синус <tt>x</tt>.</p>

<p>Одни команды не имеют операндов, например команда <tt>player</tt> всегда возвращает ссылку на игрока, а команду <tt>west</tt>
можно было бы назвать зарезервированной константой, так как она также всегда возвращает одно и то же значение — сторону <tt>west</tt>.</p>

<p>Другие команды могут иметь один или два операнда:
если у команды один операнд, то он всегда правый, иначе, это левый и правый операнды.
Если же команде требуется больше данных, то один из операндов будет массивом,
при этом команда может иметь <span tooltip="Например команда action, ей бывает нужна куча данных и поэтому она принимает массив левым операндом, хотя и правый тоже есть.
Другой пример: nearestObject — в частном случае ей нужна позиция и имя класса объекта, но у команды, тем не менее, не два операнда, а один операнд-массив. Вывод следующий — читайте комреф.
">как один, так и два операнда</span>.
Чтобы всегда быть уверенными в том верно ли вы используете ту или иную команду,
лучше всего всегда иметь под рукой комреф или один из нескольких его переводов.</p>

<p>Команды можно объединять в более сложные выражения,
например такое выражение, вернёт водителя техники, в которой находится
<span tooltip="Подразумевается, что он есть, если количество членов отряда меньше двух, пример будет давать ошибку.
Это учебный пример — на практике такие допущения делать нельзя!">«Второй» отделения игрока</span>:</p>


<pre class="hl sqf">driver vehicle (units player select 1)</pre>

<p>Откройте комреф и посмотрите описание следующих команд:
<tt tooltip="Синтаксис: driver vehicle;
Операнды: Object vehicle;
Тип возвращаемого значения: Object;
Описание: Возвращает водителя техники vehicle, если vehicle - человек, то будет возвращен сам человек.">driver</tt>,
<tt tooltip="Синтаксис: vehicle unit;
Операнды: Object unit;
Тип возвращаемого значения: Object;
Описание: Возвращает технику в которой в данный момент находится юнит unit. Если юнит не в технике, возвращается сам юнит.">vehicle</tt>,
<tt tooltip="Синтаксис: units unit;
Операнды: Object unit;
Тип возвращаемого значения: Array;
Описание: Возвращает массив всех юнитов являющихся членами отряда юнита unit. Если юнит unit мертв, будет возвращен пустой массив.
">units</tt>,
<tt tooltip="Синтаксис: player;
Тип возвращаемого значения: Object;
Описание: Персонаж управляемый игроком. В мультиплеер-режиме это значение различно на разных компьютерах
">player</tt> и
<tt tooltip="Синтаксис: array select index;
Операнды: Array array, Number index;
Тип возвращаемого значения: Any Value;
Описание: Возвращает элемент массива array указанный операндом index. Элементы массива нумеруются с нуля, так массив состоящий из пяти элементов, индексируется значениями от 0 до 4.
">select</tt>.
После того как мы ознакомились с описанием команд, отметили про себя количество и типы их операндов, мы
можем подробно рассмотреть, как будет вычисляться этот код интерпретатором:</p>
<pre class="code"><s>Синим курсивом выделено текущее подвыражение вычисляемое
интерпретатором; зеленым — промежуточный результат вычислений

Этап 1</s>
driver vehicle (<i>units player</i> select 1)
                <i>units player</i>          <s>-&gt; вернёт массив солдат</s>
                   <b>массив</b>             <s>-&gt; Array type</s>

<s>Этап 2</s>
driver vehicle (<i>массив select 1</i>)
                <i>массив select 1</i>       <s>-&gt; вернёт солдата</s>
                   <b>солдат</b>             <s>-&gt; Object type</s>

<s>Этап 3</s>
driver <i>vehicle солдат</i>
       <i>vehicle солдат</i>                 <s>-&gt; вернёт грузовик</s>
         <b>грузовик</b>                     <s>-&gt; Object type</s>

<s>Этап 4</s>
<i>driver грузовик</i>                       <s>-&gt; вернёт водителя</s>
   <b>водитель</b>                           <s>-&gt; Object type</s></pre>

<p>Это значение (водитель) может использоваться в дальнейшем, например, так мы записываем его в переменную _my_driver,
а затем отбираем у него все оружие:</p>
<pre class="hl sqf">_my_driver = driver vehicle (units player select 1)
removeAllWeapons _my_driver</pre>

<p>или делаем это одним выражением:</p>
<pre class="hl sqf">removeAllWeapons driver vehicle (units player select 1)</pre>

<p><i>Примечание: здесь используется допущение, что нужный нам водитель и второй номер группы игрока существуют,
если эти условия не будут выполняться — скрипт выдаст ошибку; это учебный пример, в действительной практике нужно выполнять явные проверки.</i></p>

<p>Возможность возвращать значение — очень важный момент, поскольку построение сложных (комплексных, составных) выражений
синтаксически основано именно на том, что команды могут иметь операнды и возвращать значения.
Поэтому, при разборе и написании выражений часто удобно думать, что круглые скобки возвращают своё содержимое,
переменная возвращает своё значение, а непосредственно указанное число возвращает самоё себя.</p>

<p>При вычислении выражений языка учитывается приоритет выполнения команд.
Аналогично тому, как в математической записи <nobr>« <tt>X + Y * Z</tt> »</nobr> вначале будет выполнено
умножение <nobr>« <tt>Y * Z</tt> »</nobr> и затем его результат будет сложен с X,
так и в выражениях  рассматриваемого языка вначале выполняются команды, имеющие больший приоритет.
В основном, это важно при использовании математических и логических операций, при равенстве приоритетов код разбирается слева направо,
круглые скобки всегда имеют высший приоритет. Более подробно о приоритетах рассказано в <a href="ofp-scripting.variable.html">главе «Переменные»</a>.</p>


<h4 id="toc01">Sqs скрипты</h4>
<h5 id="toc02">Выполнение sqs скриптов</h5>

<p>Каждый скрипт, запущенный на выполнение командой <tt>exec</tt>, будет работать в отдельном параллельном потоке
со своей собственной областью данных под локальные переменные. Вызывающая сторона после выполнения
команды <tt>exec</tt> переходит к следующей команде в потоке, не дожидаясь завершения запущенного скрипта.</p>

<p>Параллельно с выполнением команд sqs-скрипта в игре могут происходить различные события,
и фактически выполнение команд одного скрипта происходит с определёнными микропаузами.
Это следует учитывать, так как в редких случаях результат проверки некоторого
условия (например, жив ли персонаж, с которым мы работаем)
десятками строк ранее (в основном это будет долгий цикл), может стать неактуальным строкой ниже.</p>
<h5 id="toc03">Построковая структура sqs скрипта</h5>

<p>Скрипт sqs имеет построковую структуру, другими словами, самостоятельные выражения должны отделяться друг от друга символом конца строки.
С момента введения в язык функций sqf стало возможным использовать для этого «точку с запятой» («;») и записывать в одной строке
более одного выражения, однако надо следить, чтобы символ «;» не стоял в строке первым, поскольку ранее было решено зарезервировать
такую конструкцию за комментарием. Также в sqs скриптах возможны все операторы sqf функций (if then else, while do,
<span tooltip="Автор погрешил против истины назвав foreach оператором sqf функций. На самом деле foreach существовал и до появления в языке sqf, однако по ряду причин нам удобнее будет рассмотреть его в главе о функциях.
">foreach</span>), однако записываться они должны в одну строку,
что очень затрудняет написание и ухудшает читабельность такого кода.</p>
<h5 id="toc04">Передача и получение аргументов скрипта</h5>

<p>Как мы уже знаем, скрипт вызывается следующей конструкцией:</p>
<pre class="hl sqf">«arg» exec "script_filename.sqs"</pre>

<p>«arg» — передаваемый в скрипт параметр.</p>

<p>Интерпретатор не поддерживает передачу списка аргументов (и соответственно обращения к ним по имени из скрипта),
поэтому чтобы передать более одного аргумента мы должны использовать массив:</p>
<pre class="hl sqf">[_arg0, _arg1, _arg2] exec "my_script.sqs"</pre>

<p>С другой стороны, синтаксис команды exec обязывает нас всегда указывать её левый операнд,
даже если мы не хотим ничего передавать в скрипт. В качестве фиктивного аргумента вполне подойдёт ноль:</p>
<pre class="hl sqf">0 exec "some_script.sqs"</pre>

<p>Переданный параметр доступен из скрипта как предопределённая переменная <tt>_this</tt>.</p>

<p><i>Примечание: в ранних версиях игры единственным допустимым типом левого операнда exec был <tt>Array</tt>,
поэтому сложилось так, что самым популярным вариантом вызова без параметров стала передача пустого массива: «<tt>[] exec "scriptname.sqs"</tt>».</i></p>

<p>Как уже сказано, за убогостью языковых средств, для передачи ряда аргументов нам приходится использовать массив, таким образом,
чтобы удобно обращаться к каждому из них по имени мы сами должны создать переменные
и записать в них соответствующие элементы массива.
Получить указанный элемент массива позволяет команда <tt>select</tt>:</p>
<pre class="hl sqf">_arg0 = _this select 0
_arg1 = _this select 1
_arg2 = _this select 2</pre>

<p>Если же мы передавали в скрипт скаляр, то для обращения к нему можно непосредственно использовать <tt>_this</tt>.</p>
<h5 id="toc05">Комментарии</h5>

<p>Комментарий в sqs синтаксисе записывается как отдельная строка предварённая символом «;». Может смутить,
что тот же символ используется для разделения выражений записанных в одну линию, поэтому следите, чтобы комментарий
всегда стоял отдельной строкой.</p>

<pre class="hl sqf">; Это комментарий, здесь можно писать что угодно, но лучше
; комментировать свой код, хотя бы для себя.</pre>

<h5 id="toc06">Операторы управления процессом вычисления</h5>

<p>Sqs скрипт небогат на возможности управления потоком выполнения, помимо разного рода задержек
(или приостановок выполнения, о них ниже), все, что есть в нашем распоряжении — это
оператор условного выполнения «<tt>?:</tt>» и безусловный переход <tt>goto</tt></p>
<h6 id="toc07">Оператор условного выполнения ?:</h6>

<p>Оператор имеет синтаксис «<tt>? condition : expression</tt>» и в чем-то схож с <tt>if then else</tt> с «урезанным»
<tt>else</tt> — выражение <tt>expression</tt> будет выполнено лишь в том случае, если условие <tt>condition</tt> вернёт true.</p>

<p><i>Примечание для тех, кто знаком с языком C — оператор не имеет ничего общего с привычным тернарным «<tt>?:</tt>»,
в sqs этот оператор отличается семантикой, имеет два операнда и не возвращает значения.
Заменой тернарному оператору «?:» может служить select с булевым правым операндом,
а также (приятный сюрприз!) «if then else» — в рассматриваемом языке он возвращает значение (см. <a href="#AboutIfThenElse">детали</a>)
</i></p>

<p>Например, выйдем из скрипта, если он получил пустой массив в качестве аргумента:</p>
<pre class="hl sqf">? count _this == 0 : exit</pre>

<p>Но в большинстве случаев мы хотим выполнять не одно выражение, а несколько; если их немного можно
использовать «;» для того, чтобы записать их в одной строке:</p>
<pre class="hl sqf">? count _this == 0 : hint "Ошибка: не передано ни одного агрумента!"; exit</pre>
<h6 id="toc08">Метки и оператор goto</h6>

<p>Однако когда мы хотим выполнить более значительный объем кода, этот вариант совершенно не годится, и мы вынуждены
использовать оператор перехода <tt>goto</tt>.
Оператор осуществляет переход на указанную аргументом метку.
Метка должна стоять отдельной строкой и предваряться знаком шарп («#»).</p>

<p>Тот же код с использованием goto:</p>
<pre class="hl sqf">?! count _this == 0 : goto "ок"
    hint "Ошибка: не передано ни одного агрумента!"
    exit
#ок</pre>

<p>Фактически, скудный набор (или <span tooltip="О да, это не последняя подколка, любим сладкое — дружно отправляемся кодить в асм, там так сладко, что одно место может слипнуться ))">сладкая парочка</span>, судя по популярности sqs в отличие от sqf) из goto и
оператора условного выполнения позволяет реализовать весь спектр средств управления потоком.
Хотя это и не самый удобный вариант в сравнении с готовыми возможностями sqf, но если уж использовать goto,
то знать о них надо. Рассмотрим самые распространённые.</p>

<p>Конструкцию «если ... то ... иначе» короче всего можно записать если
изменить условие на обратное — обратите внимание на оператор «нот» («!»):</p>
<pre class="hl sqf">?! «condition» : goto "else"
    ; код выполняемый если «condition» истинно
    goto "endif"
#else
    ; код выполняемый если «condition» ложно
#endif</pre>

<p>В случае отсутствия части <tt>else</tt>, все упрощается до следующего:</p>
<pre class="hl sqf">?! «condition» : goto "endif"
    ; код выполняемый если «condition» истинно
#endif</pre>

<p>Так записывается цикл «do ... while ... », проверка условия выполняется в конце, т.о.
тело цикла всегда выполняется, по меньшей мере, один раз:</p>
<pre class="hl sqf">#do
    ; тело цикла выполняемое пока «condition» истинно
? «condition» : goto "do"</pre>

<p>Цикл «while ... do ... ».
В отличие от предыдущего «do while»,
тело цикла «while do» может не выполнится ни разу (проверка его условия выполняется в начале). Обычно этот цикл записывают так:</p>
<pre class="hl sqf">#while
    ?! «condition» : goto "end_loop"
    ; тело цикла выполняемое пока «condition» истинно
goto "while"
#end_loop</pre>

<p>Однако существует <span tooltip="В кругах людей занимающихся программированием на языках, вынуждающих использовать условные переходы">вариант более популярный</span> (он выносит из цикла лишний оператор):</p>
<pre class="hl sqf">goto "loop_entry"
#while
    ; тело цикла выполняемое пока «condition» истинно
    #loop_entry
? «condition» : goto "while"</pre>

<p>Аналогично записывается цикл со счетчиком:</p>
<pre class="hl sqf">_counter = _start_number
#loop
    ; тело цикла
    _counter = _counter + 1
? _counter != last_number : goto "loop"</pre>

<p>«Swicth» или выбор ветвления по ключу, имеющему тип <tt>String</tt>:</p>
<pre class="hl sqf">? _key in ["c1", "c2", "c3"] : goto _key
goto "default"

#c1
    ; выбор s1
    goto "end_switch"

#c2
    ; выбор s2
    goto "end_switch"

#c3
    ; выбор s3
    goto "end_switch"

#default
    ; выбор по умолчанию

#end_switch</pre>

<p>Если значение, по которому надо сделать выбор не относится к типу <tt>String</tt>,
можно получить строку функцией <tt>format</tt> и затем использовать её в качестве цели <tt>goto</tt>.
Этот способ неплох для типов <tt>Number</tt> (но надо следить, чтобы величина была целым числом) и <tt>Side</tt>:</p>
<pre class="hl sqf">_key = side zold
; если есть метки для всех существующих сторон (лоджик, например,
; относится к собственной строне), то проверку можно опустить
? _key in [<em>west</em>, <em>east</em>, <em>resistance</em>, <em>civilian</em>] : goto format ["%1", _key]
goto "default"

#WEST
    ; выбор для стороны west
    goto "end_switch"

#EAST
    ; выбор для стороны east
    goto "end_switch"

#GUER
    ; выбор для стороны resistance
    goto "end_switch"

#CIV
    ; выбор для стороны civilian
    goto "end_switch"

#default
    ; выбор по умолчанию

#end_switch</pre>

<p>В случае, когда ключевые величины — целые числа, подряд следующие друг за другом лучше обойтись без
использования <tt>format</tt>:</p>
<pre class="hl sqf">; массив переходов
_jmptbl = ["nA", "nB", "nC", "nD"]
; если мы укладываемся в диапазон допустимых значений: перейти
? _key &gt;= 0 &amp;&amp; _key &lt; count _jmptbl : goto ( _jmptbl select _key )
goto "default"

#nA
    ; выбор nA
    goto "end_switch"

#nB
    ; выбор nB
    goto "end_switch"

#nC
    ; выбор nC
    goto "end_switch"

#nD
    ; выбор nD
    goto "end_switch"

#default
    ; выбор по умолчанию

#end_switch</pre>

<p>Таблица переходов _jmptbl содержит имена меток для перехода,
но возможны и другие варианты с таблицами имён других sqs-скриптов, sqf-функций, а также содержащие sqf код непосредственно;
все это даёт интересные возможности при реализации алгоритмов.</p>

<p>Подводя черту под этим обзором, необходимо отметить один момент.
Когда бы ни использовался оператор «goto» вы должны чётко представлять
себе ту управляющую конструкцию, в которой он задействован. Логика кода должна
быть очевидной, поэтому не стоит злоупотреблять этим оператором.
Единственной оговоркой может быть следующее — во всех типах циклов с помощью <tt>goto</tt> можно имитировать
операторы «break» (досрочный выход из цикла) и «continue»
(досрочная передача управления в начало цикла), это вполне допустимо и не должно ухудшить код.
Можно также порекомендовать, использовать вложенные отступы для лучшего зрительного восприятия кода,
как если бы вы писали на C (или другом высокоуровневом языке), в противоположность тому, как это обычно принято в asm.</p>

<p>И всегда, когда есть такая возможность, старайтесь использовать возможности sqf-функций.</p>
<h6 id="toc09">Ожидание выполнения указанного условия @</h6>

<p>Часто в сценарии нам нужно приостановить выполнение скрипта до наступления какого-либо
события или просто на некоторое время, для этих случаев у sqs скриптов есть несколько удобных инструментов:
это операторы
«<tt>@</tt>» — ждёт выполнения условия,
«<tt>&amp;</tt>» — ждёт до указанного момента и
«<tt>&amp;</tt>» — пауза.</p>

<p>Оператор «<tt>@</tt>» ожидает наступления выполнения указанного нами условия, приостанавливая на
время ход работы скрипта.
Синтаксис оператора прост:</p>
<pre class="hl sqf">@ «condition»</pre>

<p>«condition» — любое выражение возвращающее true или false.</p>

<p>Фактически оператор выполняет выражение «condition» каждый такт игрового времени
и заканчивает свою работу, как только выражение вернёт true.
Например, следующий код ожидает посадку игрока в любую технику:</p>
<pre class="hl sqf">@ vehicle player != player</pre>

<p>Если мы хотим выполнять некоторые действия во время ожидания
(к примеру, проверку критического условия, когда дальнейшая работа скрипта не имеет смысла),
то можно разместить любое количество выражений в одну строку разделяя их символом «;»,
в таком случае условием будет считаться последнее указанное выражение:</p>
<pre class="hl sqf">@ if ( ! alive _soldier ) then { exit }; vehicle _soldier != _soldier</pre>

<p>Если условие нетривиально и код перестаёт умещаться в экранную ширину
(не более 80 символов), то код проверки удобно оформить sqf-функцией,
вынести её в отдельный файл и подключать через preprocessFile:</p>
<pre class="hl sqf">_my_condition = preprocessFile "my_condition.sqf"
@ call _my_condition</pre>

<p>Всегда делайте это через переменную, это избавит скрипт от циклической загрузки файла.</p>
<h6 id="toc10">Ожидание наступления указанного времени &amp;</h6>

<p>Оператор «<tt>&amp;</tt>», приостанавливает ход работы скрипта до указанного аргументом времени:</p>
<pre class="hl sqf">_waitUntil = _time + 10
&amp;_waitUntil</pre>
Данный пример ждёт десять секунд.

<p><i>Примечание: переменная _time содержит время прошедшее с начала старта скрипта</i></p>
<h6 id="toc11">Пауза ~</h6>

<p>Используется гораздо чаще предыдущего оператора, пример, приведенный выше может быть записан проще с помощью паузы «<tt>~</tt>»:</p>
<pre class="hl sqf">~ 10</pre>

<h6 id="toc12">Выход из скрипта</h6>

<p>Выход из скрипта должен осуществляться командой <tt>exit</tt>, часто её удобно
использовать для досрочного выхода из скрипта:</p>
<pre class="hl sqf">? count units player == 0 : exit</pre>

<p>Ну и, ради приличия, не забывайте добавлять её в конец каждого своего скрипта -))</p>
<h4 id="toc13">Sqf функции</h4>

<p>Функции sqf были добавлены в язык
<span tooltip="Можно заглянуть в комреф и выяснить версию игры в которой все это добро было предоставлено в наше распоряжение снизошедшими до простых смерных скриптовальщиков бисами">позднее</span>, и по
<span tooltip="Ну дык этож... sqs скрипты ж это как два пальца (goto и label), а энтот sqf, без сомнения, для извращенцев которым мало сёфпласпласов">ряду причин</span> получили меньшую популярность чем sqs скрипты.
Тем не менее, это наиболее удобное и мощное скриптовое средство, и
<span tooltip="На самом деле это не совсем так, при помощи стека меток, можно создать такую систему, однако это совсем низкоуровневое «скриптование», и кроме теоретического никакого иного интерса представлять не может ))">единственная
возможность создавать подпрограммы</span>.
Ранее в sqs скриптах не было механизма позволяющего выносить многократно
выполняющиеся действия в подпрограммы, что приводило в общем случае к дублированию кода,
и меньшей его прозрачности. Тот факт, что из одного sqs скрипта можно запустить другой мало спасает, так как
выполняться он будет как отдельная <span tooltip="Виртуальная машина. Имеется ввиду то, что запуск осуществляется в параллель.">ВМ</span>.</p>

<p>Sqf функции развивают идею интерпретируемых строк («code string»), использовавшихся ранее в
командах <span tooltip="Поэлементный обход массива">foreach</span> и двухоперандной форме
<span tooltip="Поэлементный обход массива с подсчетом итераций вернувших true">count</span>.
Поскольку рассматриваемый язык является интерпретируемым, то всегда существует возможность <span tooltip="Прямо во время работы программы">рантайм</span> <span tooltip="Синтаксического анализа">парсинга</span>
и выполнения любой строки содержащей выражения языка.
<span tooltip="А может просто так, от нефик делать. Бисы наперед знали, что никто юзать это не будет, иначе бы ни в жисть не добавили бы.">Чтобы сделать эту возможность более полной</span> были добавлены следующие команды:</p>
<table class="list">
<tbody>
<tr><th>call</th><th>—</th><td>самая важная, рапарсивает и выполняет строку, вызываемая сторона может получать аргументы, и возвращать значение</td></tr>
<tr><th>if then else</th><th>—</th><td>команды реализующие ветвление «если ... то ... иначе»</td></tr>
<tr><th>while do</th><th>—</th><td>команды реализующие цикл «пока ... выполнять ...»</td></tr>
<tr><th>private</th><th>—</th><td>теперь в одном файле может присутствовать несколько самостоятельных участков кода, и эта команда решает возникшую проблему с пространствами имён</td></tr>
<tr><th>loadFile</th><th>—</th><td>возвращает содержимое файла как строку</td></tr>
<tr><th>preprocessFile</th><th>—</th><td>содержимое файла обрабатывается си подобным препроцессором и возвращается как строка</td></tr>
</tbody>
</table>

<p>Для нас это в первую и главную очередь означает, что можно создавать свои функции и подпрограммы,
ну и конечно использовать средства управления потоком
<span tooltip="Есть еще «негры» (по крайней мере раньше были точно, даю зуб, что нескольких таких я видел (и даже пивал с ними пиво) в пору собственной интеллектуальной непорочности), кодящие в машинных кодах, они помнят размеры инструкций и подсчитывают смещения от условного джампа до цели перехода в уме.
Это конечно не тоже самое, что пользоваться goto, но «негры» то делают это по необходимости (или в силу особенности характера), а мы почему должны утруждать себя лишней работой?">специально
придуманные для «белых людей»</span>.
Их хоть и <span tooltip="Да-да, я хочу еще switch, ну можно еще do while, но не критично, а вот без break и continue порой неудобно, а еще очень хреново без хеш массивов, а символы строк брать нельзя и свои хеш массивы не сделаешь, вообще их даже сравнивать нельзя и призрачная надежда на бинарный поиск тает на глазах, полный попандос... пошел я кофе пить, расстройство одно">не много</span>,
этих средств, но нас, пишущих для офп, <span tooltip="Или нас густо? Если нас (или вас) «густо» пишите жалобу на ящик DenVdmj@yandex.ru, будем разбираться">тоже не густо</span>, так что нам пока хватит -))</p>

<p>Далее мы рассмотрим эти средства подробно.</p>
<h5 id="toc14">Выполнение sqf функций</h5>

<p>Как уже сказано, функция sqf представляет собой обычную строковую величину содержащую выражения языка.
Оператор <tt>call</tt> осуществляет вызов функции, фактически выполняя все выражения записанный в этой строке
и возвращая результат последнего вычисления.
Например, самая простая (и бесполезная) функция может выглядеть так:</p>
<pre class="hl sqf">_units_player = "units player"</pre>

<p>теперь вызов « <tt>call _units_player</tt> » вернёт массив юнитов игрока.
Здесь использовались двойные кавычки для того, чтобы подчеркнуть, что код выполняемый call — всего лишь строка,
однако рекомендуется использовать для этих целей исключительно фигурные скобки «{}».</p>

<p>Соответственно, чтобы выполнить любой sqf код размещенный в файле (рекомендуемое расширение .sqf)
необходимо предварительно получить строку командой preprocessFile и лишь затем вызвать оператором call:</p>
<pre class="hl sqf">call preprocessFile "my_function.sqf"</pre>

<p>Здесь, выражение « <tt>preprocessFile "my_function.sqf"</tt> » вернёт обработанное
препроцессором содержимое файла <i>"my_function.sqf"</i> в виде строки,
после чего, код записанный в этой строке выполнит команда call.
<i>(Препроцессор удалит коментарии и выполнит макроподстановку, подробнее об этом мы расскажем чуть позже.)</i></p>

<p>Теперь, ради удобства, мы можем благополучно забыть о том, что функции являются строками, и
будем вспоминать об этом лишь тогда, когда это понадобится непосредственно.</p>

<p>Функции могут принимать аргументы, так же как это делают sqs скрипты.
Пример функции возвращающей преобразованный в строку аргумент:</p>
<pre class="hl sqf">_get_as_string = { format ["%1", _this] }</pre>

<p>Мы можем вызывать эту функцию так: « <tt>player call _get_as_string</tt> », проверим:</p>
<pre class="hl sqf">hint ( player call _get_as_string )</pre>

<p>Одна sqf функция может содержать другие; например, создав файл с именем «my.sqf» и следующим содержанием:</p>
<pre class="hl sqf">private "_subfunction";

_subfunction = {
    hint "эта функция находится в другой функции"
};

call _subfunction</pre>

<p>и вызвав его из инита игрока так: « <tt>call preprocessFile "my.sqf"</tt> »,
мы увидим появившуюся подсказку с текстом «эта функция находится в другой функции».</p>

<p>Функции sqf выгодно отличает от sqs скриптов то, что в процессе их выполнения не происходят игровые события,
то есть по внутриигровому времени они выполняются мгновенно. За это достоинство
приходится платить — в sqf невозможны приостановки, вечные циклы и прочее —
все то, что так необходимо в классическом сценарии. Другими словами sqf функции являются не заменой sqs
скриптов, а очень полезным и удобным дополнением.</p>
<h5 id="toc15">Блочная структура функций</h5>

<p>Функции состоят из выражений разделяемых символом «;».
Пример, демонстрирующий общий синтаксис sqf функции:</p>
<pre class="hl sqf">_find_assoc_data = {

    // обьявляем переменные приватными
    private["_value", "_array", "_index", "_ok"];

    // получаем аргументы и инициализируем переменные
    _value = _this select 0;
    _array = _this select 1;
    _index = 0;
    _ok = <em>false</em>;

    // макро с осмысленными именами для удобного доступа
    // к нужным элементам массива
    #define VALUE (( _array select _index ) select 0)
    #define DATA  (( _array select _index ) select 1)

    // сам алгоритм
    while { !_ok &amp;&amp; _index &lt; count _array } do {

        if ( VALUE == _value ) then {
            _ok = <em>true</em>
        } else {
            if ( VALUE &gt; _value ) then {
                _index = _index + _index + 1
            } else {
                _index = _index + _index + 2
            };
        };
    };

    if ( _ok ) then { DATA } else { [] }
}</pre>

<p>Не будем вдаваться в то <span tooltip="Функа находит двоичным поиском ассоциированные со значением данные в специально сформированном массиве (пирамиде), это просто первый пришедший в голову популярный алгоритм">чем занимается эта функция</span>, пример приведен для общего представления синтаксиса.
Отметим, что нам не приходится конструировать руками цикл, мы используем для этого оператор while do.
Опять же, мы не строим нечитаемую конструкцию из меток и переходов для того, чтобы выполнить то или иное выражение —
просто используем «if then else».
Легко заметить, что нет необходимости записывать все выражения в одну строку, как это приходится делать в sqs.
Код становится читабельнее, и фигурные скобки вкупе с отступами «лесенкой» удобно отмечают начало и конец
каждого логического блока.</p>

<p>Да, поскольку в названии главы значится «блочная структура», придется сказать об этом пару слов.
Так как функции фактически состоят из операторов управления потоком и их операндов
(<i>именно так, поскольку это обычные команды принимающие строковые аргументы</i>),
а также учитывая то, что сами операторы определяют области видимости имён,
из всего этого следует, что блочная структура, в некотором роде, имеет место быть.
В <a href="ofp-scripting.variable.html#contexts">главе о переменных</a> мы
узнаем о некоторых следствиях связанных с этой особенностью.</p>
<h5 id="toc16">Передача и получение аргументов функций</h5>

<p>Передача и получение аргументов sqf функций полностью аналогичны тому как это делается в sqs.
Например, функция принимающая скаляр может просто манипулировать предопределенной
переменной _this, содержащей переданное значение:</p>
<pre class="hl sqf">_stupid_hint = {
    _this = "Hint: " + _this;
    hint _this
}</pre>

<p>Вызов с передачей аргумента выглядит так:</p>
<pre class="hl sqf">"Stupid example" call _stupid_hint</pre>

<p>Если передается несколько значений, то также, как и в случае с sqs используется массив:</p>
<pre class="hl sqf">_hint_two_strings = {
    hint (
            ( _this select 0 ) + "\n" +
            ( _this select 1 )
         )
}</pre>

<p>Вызов с передачей нескольких аргументов будет выглядеть так:</p>
<pre class="hl sqf">["Hello,", "Word!"] call _hint_two_strings</pre>

<p>Для более удобной работы с аргументами, часто имеет смысл записать их в переменные:</p>
<pre class="hl sqf">_my_sqf_function = {

    private["_arg0", "_arg1", "_arg2"];

    _arg0 = _this select 0;
    _arg1 = _this select 1;
    _arg2 = _this select 2;

}</pre>

<p>Здесь все аналогично случаю с sqs, за одним небольшим отличием — поскольку в одном файле может быть описано несколько функций,
то должна решаться проблема пространств имён. Этот момент более подробно рассмотрен
<a href="ofp-scripting.variable.html#NameSpaces">в главе о переменных</a>, а пока мы просто скажем, что все
переменные sqf функций должны быть указаны <i>приватными</i> (т.е. принадлежащими текущему контексту) командой private, как это показано в примере выше.</p>

<p>Ну и наконец, отметим, что если мы не хотим передавать аргументы,
то можем этого не делать — у call в отличии от exec может отсутствовать левый операнд.</p>

<p><span tooltip="Эти детали при первом прочтении можно опустить">Некоторые тонкости</span>.</p>

<p>Нужно также осветить один момент относительно автоматической переменной _this —
эта переменная будет присутствовать лишь в том случае, когда вы передавали в функцию аргумент,
поэтому будьте внимательны, переписывая её значение:</p>
<pre class="hl sqf">"origin value" call {
    "anything" call { _this = "new value" };
    hint _this // печатает "origin value"
}</pre>

<p>Здесь все верно, вложенная функция переписывает собственный _this,
но следующий пример показывает  возможную ошибку:</p>
<pre class="hl sqf">"origin value" call {
    call { _this = "new value" };
    hint _this // печатает "new value"
}</pre>

<p>Так как вложенная функция не получила аргумента, то для нее, соответственно,
не была создана переменная _this, поэтому присваивание «_this = "new value"»
перепишет родительский _this.</p>
<h5 id="toc17">Возвращаемое значение</h5>

<p>Функции называются так не случайно, от простых подпрограмм их
отличает то, что они способны возвращать значение.
Вспомним, что sqf функции в данном языке возвращают последнее вычисленное выражение,
например такая функция возвращает количество гранатометчиков в переданной группе:</p>
<pre class="hl sqf">_count_grenadiers = {
    {
        "" != secondaryWeapon _x
    } count units _this
}</pre>

<p>Эта функция состоит из одного выражения, результат его вычисления и будет возвращен вызывающей стороне:</p>
<pre class="hl sqf">hint format ["%1", player call _count_grenadiers]</pre>

<p>Заметьте, что в конце тела функции не надо ставить точку с запятой, иначе последним выражением
будет считаться то, что идет после «;», т.е. ничего. В качестве иллюстрации, вызов</p>
<pre class="hl sqf text">call { 10 }</pre>

<p>вернёт число 10, в отличии от вызова</p>
<pre class="hl sqf text">call { 10; }</pre>

<p>который возвращает Nothing.
Если функция заканчивается одной из веток ветвления «if then else»,
то точка с запятой должна отсутствовать не только после ветвления, <span tooltip="Почему такое вообже возможно, что функция возвращает значение в данном примере мы узнаем из рассказа о «if then else»">но и в обеих ветках</span>:</p>
<pre class="hl sqf">_max = {
    if ( _this select 0 &gt;= _this select 1 ) then {
        _this select 0
    } else {
        _this select 1
    }
}</pre>

<p><i>Примечание: в общем случае, точка с запятой не обязана стоять после каждого выражения —
этот символ отделяет одно выражение от другого, а не является признаком его конца,
как в некоторых других языках.</i></p>

<p>Очевидный момент, но все же отметим его: одиночно стоящая константа, переменная либо команда, также
являются выражением и соответственно вычисляется:</p>
<pre class="hl sqf">// возвращает все оружие группы одним массивом:
_get_group_weapons = {
    private "_w";
    _w = [];
    {
        _w = _w + weapons _this
    } foreach ( units _this );
    _w // &lt;- это выражение будет вычисленно и его результат возвращен
}</pre>

<p>Естественно, что мы можем использовать sqf функции так же, как используем команды
возвращающие значение — вызывая их непосредственно из выражений:</p>
<pre class="hl sqf">_small_arms = count ( ( player call _get_group_weapons ) - ["Binocular", "NVGoggles"] )
               - ( player call _count_grenadiers );</pre>

<p>Теперь _small_arms содержит количество единиц стрелкового оружия отделения игрока.</p>
<h5 id="toc18">Комментарии</h5>

<p>Мы уже неоднократно использовали в приводимых примерах строчные комментарии,
как несложно было заметить, символом такого комментария является двойной слэш «//» —
все, что идет после него до конца строки может быть произвольным текстом, и будет
игнорироваться интерпретатором.</p>
<pre class="hl sqf">// Это строчный комментарий
hint "подсказка" // перед комментарием может располагаться код</pre>
Если ваш комментарий занимает несколько строк, или вы хотите
временно отключить часть кода, то удобно воспользоваться многострочным комментарием —
для этого заключите текст между открывающим «/*» и
закрывающим «*/» символами, так как это сделано в примере:
<pre class="hl sqf">/*
    Это
    многострочный
    комментарий
*/</pre>
Надо отметить, что комментарии (как и макро) обеспечиваются работой команды preprocessFile,
и справедливы только для файлов подключаемых этой командой.
<h5 id="toc19">Макро</h5>

<p>Препроцессинг, осуществляемый командой preprocessFile, позволяет использовать,
помимо комментариев, <i>макроподстановку</i>.
Макроподстановка — это механизм замены символического имени на произвольный текст.
Макро определяется директивой препроцессора #define, создадим для примера макро MY_SOLDIERS:</p>
<pre class="hl sqf">#define MY_SOLDIERS (units player)</pre>

<p>теперь в файле обрабатываемом preprocessFile все вхождения имени MY_SOLDIERS будут заменены
на (units player). Можно создавать многострочные макро используя символ
переноса на следующую строку «\».</p>

<p>Макро может принимать параметры:</p>
<pre class="hl sqf">#define SOLDIERS(G) (units G)</pre>

<p>Теперь можно использовать «SOLDIERS(player)» для получения массива юнитов группы игрока.</p>

<p>Макро особенно удобно использовать для доступа к элементам массивов.
Допустим мы не хотим создавать лишние переменные для доступа к аргументам функции:</p>
<pre class="hl sqf">#define ARG0 (_this select 0)
#define ARG1 (_this select 1)
#define ARG2 (_this select 2)</pre>

<p>Здесь, как видим, используются «бессмысленные» имена макро, на деле они,
конечно, будут отражать предназначение аргументов.</p>

<p>Или еще одна область применения — язык, к сожалению, не поддерживает
пользовательские типы данных, поэтому вместо структур С или записей Паскаля,
приходится использовать массивы. Самая большая неприятность здесь заключается в том,
что надо помнить по какому смещению в массиве находится то или иное поле,
а в случае изменения порядка в котором они следуют придется переписывать весь код,
где происходит обращение к этим массивам.
Конечно, макро может очень помочь в этой ситуации, ради примера посмотрим как могли бы
выглядеть макроопределения для доступа к полям гипотетической структуры хранящей данные о юнитах:</p>
<pre class="hl sqf">// макро чтения
#define mGetVehicleType(s)    ((s) select 0)
#define mGetPosition(s)       ((s) select 1)
#define mGetIdentityHandle(s) ((s) select 2)
#define mGetStatusHandle(s)   ((s) select 3)
#define mGetAzimut(s)         ((s) select 4)
#define mGetSkill(s)          ((s) select 5)
#define mGetRank(s)           ((s) select 6)

// макро модификации
#define mSetVehicleType(s,v)    ((s) set[0,v])
#define mSetPosition(s,v)       ((s) set[1,v])
#define mSetIdentityHandle(s,v) ((s) set[2,v])
#define mSetStatusHandle(s,v)   ((s) set[3,v])
#define mSetAzimut(s,v)         ((s) set[4,v])
#define mSetSkill(s,v)          ((s) set[5,v])
#define mSetRank(s,v)           ((s) set[6,v])</pre>

<p>Областью действия макро является текст sqf скрипта, от точки определения макро, до конца файла.</p>

<p>Пару слов скажем о именах макро. В языках чувствительных к регистру символов
принято давать имена макро в верхнем регистре, это позволяет не беспокоится о случайном
совпадении имени переменной с именем макро, а также делает их легко узнаваемыми.
Однако наш интерпретатор игнорирует регистр, поэтому такой подход не будет иметь смысла —
единственное, что можно порекомендовать, это использование «специального» префикса, например «mcr_».</p>
<h5 id="toc20">Операторы управления процессом вычисления</h5>

<p>Вот мы и добрались непосредственно до операторов управления потоком.
Как мы уже отметили их не так много: ветвление «if then else» и цикл «while do»,
а также старенький, но от этого не менее полезный «foreach».
Такие вещи как например «switch» не поддерживаются, но мы покажем как можно их имитировать.</p>
<h6 id="toc21">Оператор условного выполнения if then else</h6>

<p>Этот составной оператор позволяет выполнить тот или иной код в зависимости от условия.
Синтаксис оператора:</p>
<pre class="hl sqf">if ( «condition» ) then {
    «then_expression»
} else {
    «else_expression»
}</pre>

<p>Часть «else» необязательна, и если она не нужна, то все сокращается до следующего:</p>
<pre class="hl sqf">if ( «condition» ) then {
    «then_expression»
}</pre>

<p>Здесь:</p>
<table class="list">
<tbody>
<tr><th>«condition»</th><th>—</th><td>условие</td></tr>
<tr><th>«then_expression»</th><th>—</th><td>код который будет выполнен, если «condition» истинно</td></tr>
<tr><th>«else_expression»</th><th>—</th><td>код который будет выполнен, если «condition» ложно</td></tr>
</tbody>
</table>

<p>Подробнее скажем о условии — условием является
любое выражение языка возвращающее булево (логическое) значение.
Всего существует два таких значения — true (истина) и false (ложь),
например утверждение «<tt>A &gt; B</tt>»
будет истинно (и соответственно вернёт true) если <tt>A</tt> действительно больше <tt>B</tt>,
в противном случае утверждение ложно (и возвращает false).</p>

<p>О булевом типе можно более подробно прочитать <a href="ofp-scripting.variable.html#toc05">
в главе о переменных</a>, а пока отметим
лишь, что значения с таким типом возвращают некоторые команды, например
<span tooltip="Вернёт true если объект передаваемый правым операндом жив;
на предмет других команд возвращающих boolean смотрим комреф">alive</span>,
<span tooltip="Вернёт true если объект может стрелять;
на предмет других команд возвращающих boolean смотрим комреф">canFire</span>,
<span tooltip="Вернёт true если объект может передвигаться;
на предмет других команд возвращающих boolean смотрим комреф">canMove</span>,
<span tooltip="Вернёт true если солдат сбегает с поля боя;
на предмет других команд возвращающих boolean смотрим комреф">fleeing</span>,
<span tooltip="Вернёт true если солдат пленен;
на предмет других команд возвращающих boolean смотрим комреф">captive</span>, оператор
<span tooltip="Вернёт true если в массиве указанном правым операндом есть элемент равный левому операнду;
и все равно смотрите комреф, нефига фсе в подсказки смотреть )) ">in</span>
и <i>операторы отношения</i>:</p>

<table class="list">
<tbody>
<tr><th>&gt;</th><th>—</th><th><i>истина</i>, если левый операнд больше правого, иначе <i>ложь</i></th></tr>
<tr><th>&lt;</th><th>—</th><th><i>истина</i>, если левый операнд меньше правого, иначе <i>ложь</i></th></tr>
<tr><th>&gt;=</th><th>—</th><th><i>истина</i>, если левый операнд больше правого или равен ему, иначе <i>ложь</i></th></tr>
<tr><th>&lt;=</th><th>—</th><th><i>истина</i>, если левый операнд меньше правого или равен ему, иначе <i>ложь</i></th></tr>
<tr><th>==</th><th>—</th><th><i>истина</i>, если левый операнд равен правому, иначе <i>ложь</i></th></tr>
<tr><th>!=</th><th>—</th><th><i>истина</i>, если левый операнд не равен правому, иначе <i>ложь</i></th></tr>
</tbody>
</table>

<p>Над значениями булевого типа можно совершать следующие логические операции <i>(слева дан си-подобный вариант синтаксиса,
справа в скобках — синтаксис которым могут воспользоваться сторонники паскаля)</i>:</p>
<table class="list">
<tbody>
<tr><th>&amp;&amp;  (and)</th><th>—</th><th>логичекое «<tt>И</tt>», <i>истина</i>, если оба операнда истина, иначе ложь</th></tr>
<tr><th>||  (or)</th><th>—</th><th>логичекое «<tt>ИЛИ</tt>», <i>истина</i>, если хотя бы один из операндов истина, иначе ложь</th></tr>
<tr><th>!   (not)</th><th>—</th><th>логичекое «<tt>НЕ</tt>», <i>истина</i>, если операнд ложь, иначе ложь</th></tr>
</tbody>
</table>

<p>Эти операторы, также, возвращают значения с типом Boolean.</p>

<p>Допустим есть выражение « <tt>A &gt; B &amp;&amp; C == D</tt> » (читается как «A больше B и C равно D»),
где A, B, C и D — числа (величины с типом Number),
тогда « <tt>A &gt; B</tt> » и « <tt>C == D</tt> » будут подвыражениями с типом Boolean,
(операторы больше «&gt;» и равно «==» возвращают Boolean), и
одновременно операндами логического «<tt>И</tt>» (<tt>&amp;&amp;</tt>); соответственно типом
возвращаемого значения нашего выражения будет тип возвращаемый оператором «<tt>И</tt>» (<tt>&amp;&amp;</tt>) — Boolean.</p>

<p>Создавая, таким образом, подвыражения булевого типа,
и совершая логические операции над ними мы получаем новые булевые [под]выражения;
продолжая этот процесс рекурсивно мы можем конструировать утверждения любой сложности.</p>
<p id="AboutIfThenElse"><span tooltip="Лучше пропустите эти подробности, если читаете первый раз">Некоторые тонкости</span>.</p>

<p><i>Примечание: эти интересные детали лучше пропустить при первом прочтении.</i></p>

<p>Замечательной особенностью оператора «if then else» рассматриваемого языка, является то, что он может возвращать значение.
Например:</p>
<pre class="hl sqf">_n = <em>true</em>;
hint ( if ( _n ) then { "1" } else { "2" } )</pre>

<p>щелкнет хинтом "1", или хинтом "2", если изменить _n на false.</p>

<p>Чтобы понять почему так происходит, давайте заглянем в comref и посмотрим,
что представляют собой команды if, then и else.
Ок, теперь нам понятно, что виновником такого поведения является команда then —
именно она возвращает, в нашем случае, строчку "1";
при этом значение, возвращаемое командой if станет левым операндом then, а массив,
возвращаемый командой else — правым операндом.
Расставим, для наглядности, скобки:</p>
<pre class="hl sqf">( if ( _n ) ) then ( { "1" } else { "2" } )</pre>

<p>Непривычно, но такая запись совершенно корректна для данного языка.</p>

<p>Итак, мы видим, что команда else фактически возвращает массив с двумя строковыми величинами,
а then, в зависимости от состояния своего левого операнда (он имеет специальный тип "IF") выполняет или нулевой,
или первый элемент этого массива. Это легко проверяется такими примерами:</p>
<pre class="hl sqf">_n = <em>true</em>;
if ( _n )then[{ hint "1" }, { hint "2" }]</pre>
<pre class="hl sqf">hint ( {"Alpha"} else {"Beta"} select 0 )</pre>
<pre class="hl sqf">hint ( {"Alpha"} else {"Beta"} select 1 )</pre>

<p>Здесь же уместно вспомнить, что команда select имея правым операндом булево значение возвращает
<del>или первый, или нулевой элемент</del>один из двух элементов своего левого операнда-массива:</p>
<pre class="hl sqf">_n = <em>true</em>;
hint ( {1} else {2} select _n )</pre>

<p>Вот так забавно разработчики реализовали, вполне привычные, на первый взгляд, вещи.</p>
<pre class="hl sqf">_A = 1;
_B = 2;
_cond = if ( _A &lt; _B );
_case = [
    { hint "_A &lt; _B" },
    { hint "_B &lt; _A" }
];
_cond then _case</pre>

<p>Теперь мы знаем какое безобразие прячется за маской благопристойности свойственной
классическим языкам, скрывая от нас свою порочную природу :-).
Цикл «while do», рассматриваемый далее, препарируется столь же легко, займитесь им на досуге самостоятельно.</p>
<h6 id="toc22">Оператор цикла while do</h6>

<p>Составной оператор «<tt>while do</tt>» реализует цикл, тело
которого повторяется до тех пор пока условие в части «while» истинно:</p>
<pre class="hl sqf">while { «condition» } do {
    «loop_body»
}</pre>

<p>Тело цикла <i>«loop_body»</i> будет выполняться пока истинно условие <i>«condition»</i>.
Заметьте, что условие в части «while» заключается в фигурные (т.е. это обычная анонимная sqf-функция), а не
круглые (как условие в «if») скобки, будьте внимательны.</p>

<p>Например, запишем цикл со счетчиком:</p>
<pre class="hl sqf">private "_counter";

_counter = 0;

while { _counter != 20 } do {

    // ваши действия
    _counter = _counter + 1

}</pre>

<p>Так организуется прямой обход массива:</p>
<pre class="hl sqf">private "_index";

_index = 0;

while { _index &lt; count _array } do {

    // некоторые действия над текущим элементом
    // массива (_array select _index)

    _index = _index + 1

}</pre>

<p>А так обратный:</p>
<pre class="hl sqf">private "_index";

_index = count _array;

while { _index &gt; 0 } do {

    _index = _index - 1

    // некоторые действия над текущим элементом
    // массива (_array select _index)

}</pre>

<p>Цикл типа «do while», как правило, используются реже чем «while do», но если вдруг вам он понадобился,
то можно вынести проверку в конец таким образом:</p>
<pre class="hl sqf">private "_condition";

_condition = <em>true</em>;

while { _condition } do {
    «тело цикла»
    _condition = «настоящее условие»
}</pre>

<p>Язык не поддерживает операторы break и continue, вы не можете выйти в любой момент из цикла
или начать новую итерацию, поэтому используйте
возможности <nobr>«if .. then .. else»</nobr> совместно с дополнительной
переменной — флагом «break»:</p>
<pre class="hl sqf">break = <em>false</em>;
while { _real_condition_ &amp;&amp; !break } do {

    // если необходимо прервать цикл
    if ( условие ){
        break = <em>true</em>
    } else {
        // продолжение цикла

        // если необходимо перейти в начало цикла
        if ( ! условие ){
            // продолжение цикла
        }
    }
}</pre>

<p>Цикл while не может выполняться бесконечно, и если количество итераций превысит 10000, то интерпретатор
остановит работу скрипта и выдаст ошибку.</p>
<h6 id="toc23">Оператор поэлементного обхода массива foreach</h6>

<p>Часто встречающейся задачей является выполнение некоторых действий над всеми элементами массива.
Удобным решением может быть цикл foreach, например, предыдущий пример обхода массива с «while»
мог быть записан так:</p>
<pre class="hl sqf">{
    // некоторые действия над текущим элементом
    // массива (автоматическая переменная _x)
} foreach _array</pre>

<p>Как видим код может быть короче и лаконичнее,
в примере мы обошлись без указателя текущего элемента («_index»),
вместо этого используется зарезервированная переменная «_x» —
на каждой итерации цикла она автоматически принимает значение текущего элемента массива.</p>

<p>Следующий пример восстановит здоровье всех членов отряда игрока:</p>
<pre class="hl sqf">{
    _x setDammage 0
} foreach units player</pre>

<p>Интересной особенностью foreach является то, что мы можем в ходе цикла менять сам
обрабатываемый массив, например удалить некоторые его элементы (изменив тем самым размер массива),
и интерпретатор это корректно учтёт.</p>

<p>Однако не всегда выбор надо делать в пользу foreach.
Например, если нужен параллельный обход сразу двух массивов, то мы все равно не обойдемся без
указателя текущего элемента (_index в примере с «while»), также
если нужна возможность досрочно прекратить обход (например при поиске перебором), то «while»
тоже будет правильным выбором.</p>
<h6 id="toc24">Косвенный вызов функций или имитирование оператора switch</h6>

<p><i>Примечание: эта часть несколько сложнее остальных, поэтому при первом чтении её можно пропустить.</i></p>

<p>Самый простой вариант switch может быть осуществлен лишь
для ключей удовлетворяющим следующим условиям:
они должны быть целыми числами, подряд следующими друг за другом без пропусков (как 4, 5, 6, 7, 8, 9 и т.д.),
тогда мы используем массив содержащий анонимные функции, а ключ будем использовать как индекс этого массива:</p>
<pre class="hl sqf">// привести ключ к нужному диапазону
_key = _this - 4;

// таблица анонимных функций
_switch = [
    { hint "4" },
    { hint "5" },
    { hint "6" },
    { hint "7" },
    { hint "8" },
    { hint "9" }
];

// если индекс укладывается в границы массива — вызвать нужную функцию
if ( _key &gt;= 0 &amp;&amp; _key &lt; count _switch ) then {
    call (_switch select _key)
}</pre>

<p>Это конечно здорово, но как быть если наши ключи строковые? Здесь тоже есть варианты.</p>

<p>Если строковое значение по которому надо сделать выбор не содержит пробелов и в целом
удовлетворяет требованиям к именам (см. главу <a href="ofp-scripting.variable.html#variableNames">Переменные</a>),
то можно использовать ключ как имя функции:</p>
<pre class="hl sqf">private "_switches";

// имена функций для наших ключей
_switches = [
    "_key_MY_VALUE1",
    "_key_MY_VALUE2",
    "_key_MY_VALUE3"
];

// если для ключа имеется действие (в _this ожидается ключ)
if ( "_key_" + _this in _switches ) then {

    // объявить имена функций принадлежащими текущему контексту блока then
    private _switches;

    // сами действия
    _key_MY_VALUE1 = { hint "MY VALUE 1" };
    _key_MY_VALUE2 = { hint "MY VALUE 2" };
    _key_MY_VALUE3 = { hint "MY VALUE 3" };

    // косвенный вызов
    call (call (" _key_" + _this));

} else {
    // если для ключа не нашлось действия
    hint ( "not found: """ + _this + """")
}</pre>

<p>Можно запустить этот пример так:<br> « <tt>"MY_VALUE2" call preprocessFile "этот пример помещенный в файл.sqf"</tt> »</p>

<p>В плане оптимизации можно убрать проверку « "_key_" + _this in _switches ».
В этом варианте мы лишаемся действия по умолчанию (если нужный ключ не нашелся), в остальном все остается так же:</p>
<pre class="hl sqf">private "_key_name";

_key_name = "_key_" + _this;

// предохранимся, на случай если в текущем контексте
// вдруг окажется переменная с тем же именем
private _key_name;

// имена функций
private [
    "_key_MY_VALUE1",
    "_key_MY_VALUE2",
    "_key_MY_VALUE3"
];

// сами действия
_key_MY_VALUE1 = { hint "MY VALUE 1" };
_key_MY_VALUE2 = { hint "MY VALUE 2" };
_key_MY_VALUE3 = { hint "MY VALUE 3" };

// косвенный вызов
call (call _key_name);</pre>

<p>Последний, самый сложный вариант — выбор по ключу являющимся свободной строкой.
В этом случае никакие особенности языка нам не помощники, и придется реализовывать поиск в массиве пар.</p>
<pre class="hl sqf">private["_pairs", "_findValueInPairs"];

// массив пар: ключ/функция
_pairs = [
    "- key 1 -", { hint "Key 1" },
    "- key 2 -", { hint "Key 2" },
    "- key 3 -", { hint "Key 3" }
];

// ищет прямым перебором ключ и возвращает сопоставленное ему значение
_findValueInPairs = {

    private["_a", "_k", "_i"];

    _a = _this select 0; // массив пар
    _k = _this select 1; // искомый ключ
    _i = 0;

    /*
        пока (
            (не вышли за границы массива) и
            (не нашли искомое значение)
        ) —&gt; продолжать поиск
    */
    while {
        if ( _i &lt; count _a ) then { _a select _i != _k } else { <em>false</em> }
    } do {
        _i = _i + 2
    };

    /*
        если в процессе поиска мы не вышли за границы массива
            ключ был найден, вернуть ассоциированную с ним функцию
        иначе
            вернуть анонимную функцию выводящую сообщение о неудаче
    */
    if ( _i &lt; count _a )then[{_a select (_i + 1)}, {{hint "not found"}}]

};

call ([_pairs, _this] call _findValueInPairs);</pre>

<p>Увы, нам приходится использовать прямой перебор; поскольку язык не позволяет использовать
операторы «больше» и «меньше» со строками, мы не можем оптимизировать сам
подход используя древовидное иерархическое хранение данных.</p>

<p>Обратите внимание на то как написано условие для while — вместо более очевидного:</p>
<pre class="hl sqf text">_i &lt; count _a &amp;&amp; _a select _i != _k</pre>

<p>используется возвращающий значение «if then else», объяснение здесь простое —
скрипт-интерпретатор в игре, в отличии от подавляющего большинства языков, всегда вычисляет все условие
полностью и мы можем вылететь за границы массива, порадовав игрока сообщением об ошибке (<a href="ofp-scripting.variable.html#stupidSQF&amp;SQS&amp;BIS&amp;ETC">комментарий</a>)</p>

<p>Кстати, наше условие можно упростить, убрав часть else:</p>
<pre class="hl sqf text">if ( _i &lt; count _a ) then { _a select _i != _k }</pre>

<p>Поясним: если условие « <tt>_i &lt; count _a</tt> » не будет выполнено,
то команда «then» вернёт неопределенную величину, что прекратит работу цикла.</p>

<p><i>Примечание: более того, while, в действительности, может принимать не
только булево значение, но справедливым будет считаться лишь случай когда выражение вернуло true.</i></p>

<p>И конечно, этот пример слишком сложен для простого switch (если вы не собираетесь делать выбор из сотен вариантов), и скорее подходит для хранения связанных данных.</p>

<p><i>Примечание. В примерах использовано всего несколько пар ключ/функция; если их немного, конечно, лучше использовать вложенные «if then else»
и лишь когда их более одного десятка, следует прибегать о описанным методам.
Кроме того (и ради этого, в основном, я рассказал о них) все эти примеры показывают как могут
быть реализованы в sqf структуры данных ключ/значение.</i></p>
<h5 id="toc25">Рекурсивные функции</h5>

<p>Язык «некоторым образом» поддерживает рекурсию. «Некоторым образом» —
потому, что глубина рекурсии очень невелика, и если ваша функция «нырнет» глубже положенного,
то игра, банально, вылетит. Вот пример простой тестовой рекурсивной функции:</p>
<pre class="hl sqf">_str = "";

_recurse_test = {
    if ( _this &lt; 29 ) then {
        _str = _str + format ["[%1]-&gt; ", _this];
        _this+1 call _recurse_test;
        _str = _str + format [" &lt;-[%1]", _this];
    }
};

0 call _recurse_test;

hint _str;</pre>

<p>На двух разных машинах экспериментально выяснено, что максимальная глубина равна
29 рекурсивным вызовам. Однако не стоит сильно доверять этой цифре, поэтому всегда проверяйте текущую глубину,
и прекращайте работу своего скрипта если глубина слишком большая.</p>

<p>Конечно, это рисковано, и лучше обходится совсем без рекурсии, но иногда это очень помогает,
например при написании прототипа скрипта, как в примере обхода дерева:</p>
<pre class="hl sqf">_plain = [];
_push = { _plain set [count _plain, _this] };

// разворачивает дерево
_unwrapTree = {
    if ( _this in [_this] ) then { // если не массив - вывести элемент в поток
        _this call _push
    } else {                      // если массив -
        "&lt;array&gt;" call _push;                   // обозначить это дело
        { _x call _unwrapTree } foreach _this;  // и повторить процедуру для каждого его элемента
        "&lt;/array&gt;" call _push;
    };
};

[
    1, 2, "some string",
    ["A","B","C"],
    magazines player,
    [
        ["r1c1","r1c2","r1c3","r1c4","r1c5"],
        ["r2c1","r2c2","r2c3","r2c4","r2c5"],
        ["r3c1","r3c2","r3c3","r3c4","r3c5"]
    ]

] call _unwrapTree;

_plain</pre>

<p>Уже после того как вы отладили прототип, можно ради безопасности переписать такие подпрограммы на стек.</p>

<div class="author">Copyright © <a href="https://code.google.com/u/114481294814027320015/" rel="author">DenVdmj</a>, 2006–2014.</div>
</body>
</html>
