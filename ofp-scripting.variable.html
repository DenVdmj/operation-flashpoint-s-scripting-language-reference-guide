<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Язык описания сценариев игры Operation Flashpoint. Справочное руководство. Переменные.</title>
<link href=".rsc/style.css" rel="stylesheet" type="text/css" />
<script src=".rsc/highlight.pack.js"></script>
<script src=".rsc/init.js"></script>
<script src="hyphened-text.js"></script>
</head>
<body>

<ul class="toc">
<li><a href="#toc00">Переменные, их типы и операции над ними</a>
    <ul>
    <li><a href="#toc01">Переменные, их имена, значения и типы, область видимости, зарезервированные переменные</a>
      <ul>
        <li><a href="#toc01_1">Имена переменных</a></li>
        <li><a href="#toc01_2">Инициализация переменных</a></li>
        <li><a href="#toc01_2_1">Вхождение nil в выражение</a></li>
        <li><a href="#toc01_3">Область видимости</a></li>
        <li><a href="#toc01_4">Типы переменных</a></li>
        <li><a href="#toc01_5">Зарезервированные переменные</a></li>
      </ul>
    </li>
    <li><a href="#toc02">Числа или величины с типом Number
      </a><ul>
        <li><a href="#toc03">Операции над числами и их приоритеты</a></li>
        <li><a href="#toc04">Математические функции</a></li>
      </ul>
    </li>
    <li><a href="#toc05">Логические или Булевы величины
      </a><ul>
        <li><a href="#toc07">Операции отношения</a></li>
        <li><a href="#toc08">Операции над булевыми величинами</a></li>
        <li><a href="#toc09">Приоритеты логических операций</a></li>
      </ul>
    </li>
    <li><a href="#toc10">Строки или величины с типом String
      </a><ul>
        <li><a href="#toc11">Конкатенация строк</a></li>
        <li><a href="#toc12">Преобразование значений других типов в строку — команда format</a></li>
        <!--li&gt;<a href="#toc13">Другие строковые данные — зарезервированные значения принимаемые командами, имена классов игровых объектов, имена файлов скриптов.</a>&lt;/li-->
      </ul>
    </li>
    <li><a href="#toc14">Массивы или переменные с типом Array
      </a><ul>
        <li><a href="#toc15">Массивы как наборы индексируемых значений</a></li>
        <li><a href="#toc16">Операции над массивами
          </a><ul>
            <li><a href="#toc17">Чтение элемента массива командой select</a></li>
            <li><a href="#toc18">Запись элемента массива командой set</a></li>
            <li><a href="#toc19">Изменение размера массива командой resize</a></li>
            <li><a href="#toc20">Переменная с типом Array — суть ссылка</a></li>
            <li><a href="#toc21">Конкатенация массивов</a></li>
            <li><a href="#toc22">Вычитание массивов</a></li>
            <li><a href="#toc23">Другие манипуляции с массивами</a></li></ul>
          </li>
        <li><a href="#toc24">Вложенные массивы</a></li>
        <li><a href="#toc25">Разделяемые области данных</a></li>
      </ul>
    </li>
    <li><a href="#toc26">Переменные других типов
      </a><ul>
        <li><a href="#toc27">Переменные ссылающиеся на объекты, значения с типом Object</a></li>
        <li><a href="#toc28">Переменные идентифицирующие группы юнитов, значения с типом Group</a></li>
        <li><a href="#toc29">Переменные идентифицирующие стороны, значения с типом Side</a></li>
      </ul>
    </li>
  </ul>
</li>
</ul>

<h3 id="toc00">Переменные, их типы и операции над ними</h3>

<h4 id="toc01">Переменные, их имена, значения и типы, область видимости, зарезервированные переменные</h4>

<p>Переменные — это те ячейки памяти в которых мы храним различные данные.
Принято говорить, что переменные характеризуются именем и значением. Иначе говоря, переменная — это именованная ячейка
памяти хранящая некоторое значение.
</p><p>Чтобы записать нужное значение в переменную используется оператор присваивания «=».
Левым операндом оператора должно стоять имя переменной, правым — любое выражение языка возвращающее значение.
Например напишем:
</p><pre class="hl sqf">my_variable = "some value"</pre>
<p>этот код присвоит переменной с именем my_variable строковое значение "some value".
Переменная, если она не стоит слева от оператора присваивания, всегда возвращает своё значение:</p>

<pre>
a = 11
b = 23
c = a + b
</pre>
Теперь значение переменной <tt>c</tt> равно 34.


<h5 id="toc01_1">Имена переменных</h5>

<p id="variableNames">Для имен переменных мы можем использовать латинские буквы, цифры и символ подчеркивания «_»,
при этом цифра не должна стоять первым символом в имени. Символ подчеркивания удобен для имен состоящих
из нескольких слов, как допустим <tt>enemy_units</tt>. Вообще можно рекомендовать давать переменным
«говорящие» имена: несмотря на то, что такие имена визуально увеличивают код, читать его становится удобнее.</p>
<p>В действительности офп более снисходителен и допускает
в именах локальные (в нашем случае русские) символы, однако следует склониться к тому, что это не самая хорошая
идея и придерживаться общепринятых правил.</p>
<p>Синтаксис языка нечувствителен к регистру символов, таким образом имена _mySuperPuperVariable и _mysuperpupervariable
рассматриваются интерпретатором как одно и тоже имя (эквивалентны).</p>
<p>Будьте осторожны с выбором имен переменных — если выбранное имя случайно совпало с
именем команды, например, в результате создания переменной таким образом: «<tt>ammo = magazines player</tt>»,
то игра не выдаст ошибку, однако теперь эта команда (в нашем случае «ammo») будет недоступна.
Конечно, случайно допустить такую ошибку сложно, ведь большинство команд имеют сложносоставные имена,
и, со временем, вы все их запомните, но тем не менее, знать о таком поведении интерпретатора все-же стоит.</p>

<h5 id="toc01_2">Инициализация переменных</h5>

<p id="nilValue">Язык не требует обязательного предварительного объявления переменных, но до начала использования они
должны быть проинициализированы каким-либо значением.</p>

<p>Если переменная не существовала ранее, то обычное присваивание создаст новую переменную с указанным именем.
Переменная не содержащая никакого значения возвращает специальную величину nil
(проще говоря, отсутствие какого либо значения), попытка преобразования в
строку (см. команду format) вернёт "scalar bool array string 0xfcffffef".
Это важно, так как вхождение величины nil в любое выражение приводит к прекращению его дальнейшего вычисления,
например, здесь не будет выполнен не только блок then, но и блок else:</p>

<pre class="hl sqf">if ( <em>nil</em> ) then {
    hint "не будет выполнено"
} else {
    hint "также не будет выполнено"
}</pre>

<p>Поэтому внимательно следите за тем чтобы все ваши переменные были проинициализированы.</p>
<p>Если сложно гарантировать, что используемая переменная существует на момент выполнения,
или вы хотите писать надежный код, приспособленный к такого рода неприятностям,
то следующие примеры помогут разобраться с этим нюансом. Так, вместо:</p>

<pre class="hl sqf">; Здесь проблема в том, что если myGlobalFlag не существует на момент
; вычисления, то вхождение в следующие выражение неинициализарованного
; значения (nil) оборвет его выполнение и команда exit не будет выполнена:
?! myGlobalFlag : exit
; код который будет выполнен, если myGlobalFlag вернула false</pre>
используйте:
<pre class="hl sqf">; В данном случае, если myGlobalFlag неопределена, то не будет
; перехода к «#OK», аналогично тому, как если бы myGlobalFlag вернула false
? myGlobalFlag : goto "OllKorrect"
    exit
#OllKorrect
; код который будет выполнен, если myGlobalFlag
; вернула либо false либо nil (неинициализирована)</pre>
<p>Аналогично для sqf:</p>
<pre class="hl sqf">_proxyFlag = <em>false</em>
// если myGlobalFlag неопределена, то следующее выражение не будет выполнено
if ( myGlobalFlag ) then { _proxyFlag = <em>true</em> };
// теперь, _proxyFlag гарантированно существует и имеет значением false либо true
if ( _proxyFlag ) then {
    // код который будет выполнен, если myGlobalFlag
    // вернула либо false либо nil (неинициализирована)
}</pre>

<p><i>Примечание. Часто с подбными целями используется ряд других «хаков».
Как правило основной используемый прием — преобразование значения «опасной»
переменной к строке:
</i></p>
<pre class="hl sqf">if (
    format ["%1", GlobalIdentifier] == "scalar bool array string 0xfcffffef"
) then {
    hint "Symbol not defined";
    GlobalIdentifier = [];
}</pre><i>

<p>Можно преобразовывать в строку не само значение, а результат некоторой операции над ним.
Вот несколько примеров:</p>
<pre class="hl sqf">// Для переменных любых типов:
if ( format ["%1", GlobalVar in []] == "bool" ) then {
    /* инициализация */
}

// Для переменных массивов:
if ( format ["%1", count GlobalArray] == "scalar" ) then {
    /* инициализация */
}

// Для скалярных переменных:
if ( format ["%1", GlobalVar == GlobalVar] == "bool" ) then {
    /* инициализация */
}

if ( format ["%1", GlobalVar + GlobalVar] == "scalar" ) then {
    /* инициализация */
}</pre>

<p>Ну и наконец можно вовсе обойтись без некрасивой format:</p>
<pre class="hl sqf">// Для массивов:
if ( 0 == { _x &gt;= 0 } count [count GlobalArray] ) then {
    /* инициализация */
}

// Для скалярных значений
if ( 0 == { _x == _x } count [GlobalScalar] ) then {
    /* инициализация */
}</pre>
</i>

<h6 id="toc01_2_1">Вхождение nil в выражение</h6>
<p>Краткая формулировка такого поведения интерпретатора звучит как
«вхождение nil в выражение». Это просто запомнить — если в выражении
обнаружена неинициализированная величина, вычисление выражения прекращается, само выражение,
при этом, также вернёт nil. Например, вхождение nil в условие цикла while, прекратит его выполнение, вызов</p>
<pre class="hl sqf output"><em>nil</em> call { hint "не выполняется" }</pre>
также не будет выполнен, и т.д.
<p>Но например</p>
<pre class="hl sqf output">[<em>nil</em>] call { hint "уже гораздо лучше" }</pre>
<p>вполне работоспособен, поскольку в данном случае nil и call не участвуют в одном выражении.</p>

<h5 id="toc01_3">Область видимости</h5>

<p id="NameSpaces">Переменные могут отличаться <i>областью видимости</i>.
Все переменные не имеющие в имени префикса «_» имеют глобальную область видимости.
Это означает, что такая переменная доступна в любом скрипте или функции (включая строки
инициализации, поля триггеров и прочее, другими словами из любого места игры,
где есть возможность использовать скриптовые выражения).
Имя переменной начинающееся с символа подчеркивания делает её локальной,
например <tt>_temp_variable</tt> — локальная переменная.
В отличии от глобальных, локальные переменные видны только в том
<i>контексте</i> в котором они созданы.</p>
<p>Это влияет и на время жизни переменной — при выходе из контекста (как правило скрипта
или блока в котором переменная создана) она удаляется и память отведенная под нее освобождается.</p>
<p><i>Примечание: под контекстом, здесь и в других местах текста,
подразумевается то, что определяет область видимости, например, контекстом команды «call» будет её правый строковый
операнд (т.е. функция), аналогично контекстом «do» будет её блок (правый строковый
операнд, код заключенный в фигурные скобки «{}»).</i></p>
<p id="contexts">Поскольку в sqf функциях могут быть вложенные контексты,
то возможна ситуация когда имя переменной созданной
во вложенном контексте уже используется во внешнем. Например:</p>
<pre class="hl sqf">_my_var = "это переменная доступна в текущем и во всех вложенных контекстах";

player sideChat _my_var;

call {
    player sideChat _my_var;
    _my_var = "однако её можно случайно испортить создав другую с тем же именем";
    player sideChat _my_var;
};

player sideChat _my_var;</pre>
Для разрешения такой ситуации необходимо <i>явно</i> объявлять переменные <i>приватными</i>:
<pre class="hl sqf">_my_var = "это переменная доступна в текущем и во всех вложенных контекстах";

player sideChat _my_var;

call {
    player sideChat _my_var;
    private "_my_var"; // &lt;— Объявляем приватную переменную
    _my_var = "однако её можно временно перекрыть объявив другую с тем же именем";
    player sideChat _my_var;
};

player sideChat _my_var;</pre>
<p>Теперь переменная существующая во внешнем контексте уже не перезаписывается,
а вместо этого создается новая локальная переменная с таким же именем.
При выходе из блока вызываемого командой call эта новая переменная будет уничтожена, в то
время как старая переменная по прежнему доступна.</p>
<p>Как видно из приведенных примеров, объявление приватной переменной осуществляется оператором <tt>private</tt>.
Оператор имеет два варианта синтаксиса, в первом случае указывается список имен переменных:</p>
<pre class="hl sqf">private «variable names list»</pre>
<p>операнд  <tt>«variable names list»</tt> — массив имен приватных переменных,
имена необходимо задавать как строки заключая их в кавычки:</p>
<pre class="hl sqf">private [
    "_private_variable1",
    "_private_variable2",
    "_private_variable3"
]</pre>
<p>На тот случай, когда надо объявить приватной лишь одну переменную, команда private поддерживает краткий
синтаксис:</p>
<pre class="hl sqf">private "_private_variable"</pre>

<p>Строго рекомендуется все локальные переменные sqf функций объявлять
приватными, лишь за исключением тех случаев, когда вы осознанно желаете получить иной эффект.</p>
<p>В следующем примере показано как пренебрежение этим правилом приводит к ошибке:</p>
<pre class="hl sqf">if ( <em>true</em> ) then {
    _some_var = "За пределами контекста блока then меня не существует!"
};
hint _some_var</pre>
<p>Эта функция ничего не делает, поскольку после выхода из then блока переменная
_some_var будет уничтожена, и соответственно hint не сработает (вхождение nil в выражение). Вы можете заменить строку
«<tt>hint _some_var</tt>» на «<tt>hint format ["%1", _some_var]</tt>» чтобы убедится в том,
что _some_var — неопределенная величина.
Поправить ситуацию можно заранее объявив переменную приватной:</p>
<pre class="hl sqf">private "_some_var";

if ( <em>true</em> ) then {
    _some_var = "Я объявлена в родительском контексте, а в текущем проинициализирована!"
};

hint _some_var</pre>

<p><i>Примечание: вложенность контекстов появляется не только при использовании
команды call, каждая из нижеперечисленных команд создает свой контекст:
<tt>foreach</tt>, <tt>count</tt>, <tt>while</tt>, <tt>do</tt>, <tt>then</tt>, <tt>exec</tt>.
Однако, поскольку контекст, создаваемый командой exec, не имеет родительского контекста,
объявление всех локальных переменных запущенного с помощью <tt>exec</tt> скрипта приватными обычно не будет иметь смысла.</i></p>
<p>Итак, поскольку это важный момент, рассмотрим его с точки зрения интерпретатора.
Встречая во <i>вложенном контексте</i> (блоке, буквально: строковом операнде команд while, do, then, foreach, count, call)
любую локальную (с префиксом «_») переменную,
интерпретатор просматривает родительские (внешние по отношению к текущему) контексты на наличие переменной с таким именем;
если такая переменная уже существует — то будет использована она,
в противном случае будет создана новая, принадлежащая текущему контексту, локальная переменная.</p>

<h5 id="toc01_4">Типы переменных</h5>

<p>Значения переменных могут относится к различным <i>типам</i>.</p>
<p>В офп существуют следующие основные типы переменных:</p>
<ul>
<li><b>Number</b> — числа;
</li><li><b>Boolean</b> — логические величины — true (истина), false (ложь), эти значения, как правило,
результаты операций сравнения (отношения), например выражение: 2 &lt; 1 вернёт ложь (false);
</li><li><b>String</b> — строки, такие как "просто строка";
</li><li><b>Array</b> — массив, набор индексируемых значений любых типов;
</li><li><b>Object</b> — игровые объекты;
</li><li><b>Group</b> — специальный тип, переменные с таким типом идентифицируют группу (отделение) бойцов;
</li><li><b>Side</b> — специальный тип, переменные с таким типом идентифицируют противоборствующие стороны к которым принадлежат юниты.
</li></ul>

<p>Допустим у нас есть переменная _soldier и её значением на данный момент является некий юнит
(фактически ссылка на игровой объект);
очевидно, что мы не можем сложить его с числом, сравнить с массивом, и т.д. Это не только не имеет смысла,
но и в принципе не существует реализации таких действий у интерпретатора языка.
Поэтому любое значение хранящееся в переменной неявно связано с <i>типом</i>. Любые действия,
выполняемые операторами или командами офп возможно выполнять лишь над данными определенного типа:
складывать, умножать, делить, сравнивать — числа, проверять на идентичность — объекты или стороны,
объединять — массивы с массивами или строки со строками.
При несоответствии типов интерпретатор будет выдавать соответствующую ошибку.</p>
<p><i>Примечание: всегда обращайте внимание на типы операндов указанные для команд в комрефе,
учитывайте тип возвращаемого значения и вы избежите подобных ошибок.</i></p>
<p>Переменные в офп могут принимать значения любого типа, к примеру мы можем присвоить число
переменной, содержавшей до этого, допустим, строку, а затем, ссылку на игрока. Поскольку типы
связываются со значением, а не с самой переменной, то такие присваивания допустимы — прежние
значения при этом будут просто затерты.</p>

<h5 id="toc01_5">Зарезервированные переменные</h5>

<p>Существуют также предопределенные зарезервированные переменные:
<br>_this — с этой переменной мы уже знакомы, с её помощью реализован механизм передачи агрументов в скрипты и sqf-функции;
<br>_time — содержит время, прошедшее с момента старта скрипта</p>
<p>Можно отметить также существование специальных, используемых интерпретатором переменных, их имена начинаются
с двух символов подчеркивания «__», в будущем их наличие и количество может измениться
(именно поэтому вы не должны ни обращаться к ним, ни определять свои с тем же префиксом).</p>
<p><i>Примечание: примером такой переменной может быть <tt>__waitUntil</tt>;
интересным моментом является то, что задержку <tt>~</tt> интерпретатор раскрывает в подобный код:
</i></p>
<pre class="hl sqf">__waitUntil = _time + (cas)
&amp;__waitUntil</pre>


<h4 id="toc02">Числа или величины с типом Number</h4>
<p>Использование чисел возможно как непосредственно, допустим: 123.456 — константа,
так и в качестве значений переменных.</p>
<p>Форматы записи констант:</p>
<pre class="text">
1230
0.123e4
.123e4
0.123
.123
0.123e7
1.23e+006
</pre>

<h5 id="toc03">Операции над числами и их приоритеты</h5>

<p>Двухместные арифметические операции над числами:</p>
<pre class="text">
+     <s>возвращает сумму своих операндов</s>
-     <s>вычитает из левого операнда правый и возвращает результат</s>
*     <s>возвращает произведение своих операндов</s>
/     <s>делит левый операнд на правый и возвращает результат</s>
%     <s>возвращает остаток от деления левого операнда на правый,</s>
      <s>важно, что операнды могут быть нецелыми числами.</s>
mod   <s>аналогично %</s>
^     <s>операция возведения в степень</s>
</pre>
<p>Унарные операции:</p>
<pre class="text">
-     <s>меняет знак числа на противоположный</s>
+     <s>возвращает само число</s>
</pre>
<p>Перечислим операции по убыванию приоритетов: унарные плюс и минус имеют высший приоритет,
далее следует операция возведения в степень (<tt>^</tt>),
затем идут операции умножения, деления и взятия остатка
(<tt>*</tt>, <tt>/</tt>, <tt>%</tt> — их приоритеты равны между собой), и низший
приоритет имеют операции сложения и вычитания.</p>
<p>В языке отсутствует операция отбрасывания дробной части числа, но к счастью оператор взятия
остатка здесь может работать и с вещественными значениями, что даёт нам возможность легко написать свой int:</p>
<pre class="hl sqf">_int = { _this - _this % 1 }</pre>
<p>Операции проверки отношения и равенства перечислены в главе о булевом типе (см. <a href="#toc05">следующую главу</a>).</p>

<h5 id="toc04">Математические функции</h5>

<p>Здесь коротко описаны основные математические функции поддерживаемые языком:</p>
<pre class="text">
abs     <s>абсолютное значение числа;</s>

deg     <s>переводит из радиан в градусы;</s>
rad     <s>переводит из градусов в радианы;</s>

exp     <s>экспонента;</s>
log     <s>десятичный логарифм;</s>

sin     <s>возвращает синус числа;</s>
cos     <s>возвращает косинус числа;</s>
tan     <s>возвращает тангенс числа;</s>

asin    <s>возвращает арксинус числа;</s>
acos    <s>возвращает арккосинус числа;</s>
atan    <s>возвращает арктангенс числа;</s>
atan2   <s>арктангенс результата деления левого операнда на правый,</s>
        <s>двухместная операция;</s>

sqrt    <s>корень квадратный;</s>

pi      <s>число pi.</s>
</pre>
<p>Приоритеты этих функций выше приоритетов операторов, например:</p>
<pre class="hl sqf">sqrt 4 * 4</pre>
аналогично
<pre class="hl sqf">( sqrt 4 ) * 4</pre>
возвращает 8, в отличии от
<pre class="hl sqf">sqrt( 4 * 4 )</pre>
возвращающего 4.

<p><i class="nlremark">Примечание: Другие команды могут иметь больший или меньший приоритет, как например, команда select.
Во всех случаях когда вы не уверены в порядке вычисления используйте группирующие скобки</i></p>

<p><i class="nlremark">Примечание: в языке нет операторов инкрементирования и декрементирования, подобных <tt>++</tt> и <tt>--</tt>, побитовой арифметики также нет.</i></p>

<h4 id="toc05">Логические или Булевы величины</h4>

<p id="toc06">Переменные булевого типа способны принимать одно из двух значений — true (истина) и false (ложь).
Логические величины могут возникать как результат вычисления операций отношения, например «&gt;» больше, «&lt;» меньше или проверка на равенство «==»;
как возвращаемое значение некоторых команд, например <tt>unitReady</tt>, <tt>someAmmo</tt> или <tt>stopped</tt>;
либо как непосредственно указанные true или flase.</p>

<p>Здесь мы рассмотрим как сами операции отношения, возвращающие логические значения, так и операции над этоими значениями.</p>

<h5 id="toc07">Операции отношения</h5>

<p>Мы можем сравнивать числа следующими операторами:</p>
<pre class="text">
&gt;    — <s><i>true</i>, если левый операнд больше правого</s>
&lt;    — <s><i>true</i>, если левый операнд меньше правого</s>
&gt;=   — <s><i>true</i>, если левый операнд больше правого или равен ему</s>
&lt;=   — <s><i>true</i>, если левый операнд меньше правого или равен ему</s>
==   — <s><i>true</i>, если левый операнд равен правому</s>
!=   — <s><i>true</i>, если левый операнд не равен правому</s>
</pre>
<p>Сравнивать объекты, стороны, группы (переменные с типами Object, Side, Group соответственно)
можно только операторами проверки равенства:</p>
<pre class="text">
==   — <s><i>true</i>, если левый операнд идентичен правому</s>
       <s>(если это тот-же самый объект, группа, сторона)</s>
!=   - <s><i>true</i>, если левый операнд не идентичен правому</s>
       <s>(если это разные объекты, группы, стороны)</s>
</pre>
<p>Аналогично для строк (для переменных с типом String):</p>
<pre class="text">
==   - <s><i>true</i>, если левый операнд равен правому</s>
       <s>(если строки одинаковы)</s>
!=   - <s><i>true</i>, если левый операнд отличен от правого</s>
       <s>(если строки разные)</s>
</pre>
<p>Операции сравнения строк игнорируют регистр, если сравниваются символы с кодами до 80h
(буквы английского алфавита, цифры и некоторые стандартые символы),
и учитывают регистр при сравнении символов 80h-FFh (символы локальных кодировок, в нашем случае русские буквы).
Таким образом утверждение:</p>
<pre class="hl sqf">"Hello, Word!" == "hello, word!"</pre><p>справедливо, тогда как</p>
<pre class="hl sqf">"Привет, Мир!" == "привет, мир!"</pre><p>ложно.</p>
<p>Некоторые очевидные равенства:</p>
<pre class="text">
a &gt; b   <i>равносильно</i>  !(a &lt;= b)
a &lt; b   <i>равносильно</i>  !(a &gt;= b)
a &lt;= b  <i>равносильно</i>  !(a &gt; b)
a &gt;= b  <i>равносильно</i>  !(a &lt; b)
</pre>

<p>Увы, но в этой главе ничего не говорится о сравнении переменных с типом Array (массивов).
Несмотря на то, что эти переменные на деле являются ссылками (см. <a href="#toc20">детали</a>),
в языке нет возможности проверки на идентичность таких переменных (еще <a href="#subtraction_array">детали</a>).</p>

<h5 id="toc08">Операции над булевыми величинами</h5>

<p>В офп присутствуют три основные логические операции:</p>
<ul>
<li>логическое «и»
<br>синтаксис: <tt>a &amp;&amp; b</tt>
<br>синтаксис, «паскаль» стиль: <tt>a and b</tt>
<br>возвращает true только в том случае, когда оба операнда true;
</li><li>логическое «или»
<br>синтаксис: <tt>a || b</tt>
<br>синтаксис, «паскаль» стиль: <tt>a or b</tt>
<br>возвращает true в том случае, если хотя бы один из операндов true;
</li><li>логическое отрицание «не»
<br>синтаксис: <tt>!a</tt>
<br>синтаксис, «паскаль» стиль: <tt>not a</tt>
<br>возвращает true, если операнд false и наоборот.
</li></ul>


<p>В языке сценариев офп нет такой важной логической операции как «исключающее или», которая возвращает true,
если лишь один из операндов true. Также мы не можем сравнивать логические величины на предмет равенства,
поэтому эти операции мы имитируем так:</p>
<pre class="hl sqf">!(a &amp;&amp; b) &amp;&amp; (a || b)</pre>
<p>Это выражение вернёт true только в том случае, если true либо <tt>a</tt> либо <tt>b</tt>, или
другими словами, если <tt>a</tt> не равно <tt>b</tt>.</p>
<p><i>Примечание: важно, что выполнять операции можно лишь над переменными, содержащими данные одного типа,
то есть объект можно сравнивать только с объектом, сторону со стороной, а строки со строками.
Так как результат сравнения, например, стороны с объектом не имеет смысла (более того - такое сравнение невозможно), то
при попытке выполнить такой код скриптинтерпретатор сообщит об ошибке несоответствия типов
данных (что то типа следующего: «Any Value. Ожидался Object»).
Это замечание относится ко всем типам данных и операциям над ними (а не только операциям сравнения).</i></p>

<h5 id="toc09">Старшинство логических операций</h5>

<p>Все операторы отношения имеют меньший приоритет чем операторы арифметические.
Другими словами запись:</p>
<pre class="hl sqf">_a - _b &gt; _c * _d</pre>
будет равносильна
<pre class="hl sqf">( _a - _b ) &gt; ( _c * _d )</pre>

<p>Поскольку сравнивать булевы величины мы не можем, вопрос о приоритете
операторов отношения относительно друг друга не имеет смысла (т.к. все они возвращают boolean).</p>
<p>Приоритет операторов <tt>&amp;&amp; и</tt> <tt>||</tt> ниже чем у арифметических операторов и операторов отношения:</p>
<pre class="hl sqf">_a - _b &gt; _c * _d &amp;&amp; _n &lt;= _m || _f != _z</pre>
равносильно
<pre class="hl sqf">(( _a - _b ) &gt; ( _c * _d )) &amp;&amp; ( _n &lt;= _m ) || (_f != _z)</pre>

<p>Приоритет выполнения оператора <tt>&amp;&amp;</tt> больше чем у <tt>||</tt>, т.о. выражение:</p>
<pre class="hl sqf"><em>true</em> || <em>false</em> &amp;&amp; <em>false</em></pre>
вернёт true, в отличии от:
<pre class="hl sqf">(<em>true</em> || <em>false</em>) &amp;&amp; <em>false</em></pre>
<p>возвращающего false.</p>
<p>Приоритет унарного «!», выше приоритета любых других операторов.</p>
<p>Если вы не уверены в том порядке в котором будет происходить вычисление вашего выражения, не стесняйтесь
использовать лишние скобки.</p>
<p id="stupidSQF&amp;SQS&amp;BIS&amp;ETC">Важной (и скажем так, не лучшей) особенностью языка является полное вычисления выражения даже в том случае когда его результат уже известен.
Например следующее выражение нет нужды вычислять полностью:</p>
<pre class="hl sqf">(1 &gt; 2) &amp;&amp; call { hint "Не имеет никакого смысла вызывать меня!"; <em>true</em> }</pre>
<p>Очевидно, что раз выражение в первых скобках <i>ложно</i> (единица <i>не</i> больше двойки) то и все выражение никогда не вернёт true,
однако скриптинтерпретатор офп вычисляет его полностью. Будьте осторожны.</p>
<p>Эту особенность можно продемонстрировать на таком примере — допустим, существует условие победы в миссии:
    ( ( ключевой персонаж мертв ) и ( на острове нет боеспособных танков противника ) ).
Ключевой персонаж, может быть убит только в самом конце миссии, и сделать это очень непросто,
а проверка на боеспособность танков влечет за собой перебор всех юнитов на карте
с выяснением ущерба, наличия стрелка и способности вести огонь.
Вы решаете ускорить вычисление выражения вынося в начало простую проверку !alive и
затем вызов скрипта вычисляющего сложную часть условия:</p>
<pre class="hl sqf">!alive Villian &amp;&amp; call funcVictoryCondition</pre>
<p>Это не сработает в связи с указанной выше причиной, и скрипт funcVictoryCondition будет
вызываться на каждый тик игрового времени, поэтому придется поступить так:</p>
<pre class="hl sqf">if ( !alive Villian ) then { call funcVictoryCondition } else { <em>false</em> }</pre>

<p>Ну и в завершение рассказа о типе Boolean, давайте детально разберем следующий пример:</p>
<pre class="hl sqf">leader player == player &amp;&amp; 1 &lt; count units player</pre>
<p>Это выражение вернёт истину, только если игрок является командиром своего отряда
и при этом ему действительно есть кем командовать.
Итак, так же как и раньше, мы открываем комреф и смотрим описание команд:
<tt>leader</tt>, <tt>player</tt>, <tt>units</tt>, <tt>count</tt>,
<tt>==</tt>, <tt>&lt;</tt> и <tt>&amp;&amp;</tt>; особенное внимание обратим на типы операндов и возвращаемых значений.
Теперь мы можем поэтапно рассмотреть как будет вычисляться наше выражение:</p>
<pre class="code">
<s>Синим курсивом выделено текущее подвыражение вычисляемое
интерпретатором; зеленым — промежуточный результат вычислений

Этап 1</s>
<i>leader player</i> == player &amp;&amp; 1 &lt; count units player
<i>leader player</i>              <s>-&gt; вернёт человека — лидера игрока</s>
   <b>человек</b>                 <s>-&gt; Object type

Этап 2</s>
<i>человек == player</i> &amp;&amp; 1 &lt; count units player
<i>человек == player</i>          <s>-&gt; вернёт булевое значение, true или false</s>
<b>булевое_значение</b>           <s>-&gt; Boolean type


Этап 3</s>
булевое_значение &amp;&amp; 1 &lt; count <i>units player</i>
                              <i>units player</i>  <s>-&gt; вернёт массив солдат</s>
                                 <b>массив</b>     <s>-&gt; Array type

Этап 4</s>
булевое_значение &amp;&amp; 1 &lt; <i>count массив</i>
                        <i>count массив</i>   <s>-&gt; вернёт количество элементов</s>
                           <b>число</b>       <s>-&gt; Number type

Этап 5</s>
булевое_значение &amp;&amp; <i>1 &lt; число</i>
                    <i>1 &lt; число</i>          <s>-&gt; вернёт булевое значение</s>
                 <b>булевое_значение</b>      <s>-&gt; Boolean type

Этап 6</s>
<i>булевое_значение &amp;&amp; булевое_значение</i>   <s>-&gt; вернёт булевое значение</s>
          <b>булевое_значение</b>             <s>-&gt; Boolean type</s>
</pre>
<p>Проверте себя — закройте страницу и расставьте в этом выражении группирующие скобки.</p>

<h4 id="toc10">Строки или величины с типом String</h4>

<p>Данные с типом String — это обычные текстовые строки, используемые непосредственно, как например <tt>hint "Hello World!"</tt>,
или в качестве значений переменных, допустим:</p>
<pre class="hl sqf">// создаем переменную,
_greeting = "Hello World!";

// выводим подсказку в правом верхнем углу экрана
hint _greeting;

// плавное появление надписи внизу по центру
titleText [_greeting, "plain down"]</pre>

<h5 id="toc11">Конкатенация строк</h5>

<p>Существует несколько способов объединить строки, первый и более простой — это оператор <tt>+</tt>
(оператор объединения или конкатенации строк):</p>
<pre class="hl sqf">_example_text = "эта строка будет склеена с " + "другой строкой"</pre>
<p>Выведем подсказку с именем игрока:</p>
<pre class="hl sqf">hint ( "Ваш ник: " + name player )</pre>
<p><i class="nlremark">Примечание: операция <tt>+</tt> — единственная операция над строками, увы, мы не можем ни разбивать строки, ни брать нужный символ и получать его код, из операций отношения доступны лишь операции проверки равенства.</i></p>

<h5 id="toc12">Преобразование значений других типов в строку — команда format</h5>

<p>Другой способ объединения строк заключается в использовании команды format:</p>
<pre class="hl sqf">format ["%1%2", "эта строка будет склеена с ", "другой строкой"]</pre>
<p>Теперь, в строку <tt>"%1%2"</tt>, в места указанные спецификаторами вида <tt>%number</tt> будут
вставлены строки, перечисленные далее.</p>
<p>Этот способ, очевидно, сложнее первого и целесообразность
его использования была бы сомнительной, если бы не другое важное свойство команды —
<i>типы форматируемых величин могут быть любыми</i>. При этом format преобразует эти величины к строкам
и затем «вклеивает» их в управляющую строку.
Спецификатор состоит из предваряемого знаком процента «%» числа — индекса элемента который будет
помещен на место спецификатора<!-- (мы помним, что массивы индексируются с нуля)-->.
Управляющая строка может содержать более одного спецификатора указывающего на один и тот же элемент;
спецификаторы могут появляться в любом порядке.</p>
<p>Допустим мы хотим вывести здоровье игрока, но есть одна маленькая проблема — команда getDammage
возвращает число, а выводить на экран мы можем только строки, поэтому нам необходимо использовать format:</p>
<pre class="hl sqf">hint format [
    "Здоровье игрока: %1%2", (1 - getDammage player) * 100, "%"
]</pre>
<p>Команда getDammage возвращает текущий урон, величину, фактически, обратную здоровью, как значение
от 0 до 1; таким образом, выражение « <tt>(1 - getDammage player) * 100</tt> » вернёт здоровье игрока в процентах;
поскольку знак процента является зарезервированным символом для управляющей строки (командой format он
распознается как часть спецификатора <tt>"%<i>число</i>"</tt>), то его мы «вклеиваем» отдельно.</p>
<p>Попробуйте следующий пример:</p>
<pre class="hl sqf">_player_info = format ["Игрок %1 сражается на стороне %2\n" +
    "в составе отделения %3 из %4 человек.\nВот они наши герои:\n%5",

    player,                  // объект
    side player,             // сторона
    group player,            // группа
    count units player,      // число
    units player             // массив объектов
];
titleText [_player_info, "plain down"];</pre>
<p><i>Примечания:
</i></p>
<p><i>Многие средства вывода строк на экран — команды hint, titleText,
поля редактирования и текстовые поля в диалогах, и некоторые другие,
распознают в тексте, предназначенном для вывода, управляющую последовательность "\n", сами символы последовательности
при этом не выводятся, а инициируют переход на новую строку.
</i></p>
<p><i>Кроме того, мы разбили управляющую строку на две  и склеиваем их оператором <tt>+</tt> — это не несет
никакой смысловой нагрузки и сделано исключительно ради того, чтобы текст примера уместился на экранную страницу.
</i></p>
<p><i>Этот пример, как и большинство других примеров здесь, дан в sqf синтаксисе, чтобы запустить
его поместите текст примера в файл «function_filename.sqf» и используйте выражение: call preprocessFile "function_filename.sqf".
</i></p>
<p>Итак, мы видели как команда format преобразует числа, объекты, стороны, группы и массивы в строки.
С любыми другими типами она справится так же хорошо.
Все это делает команду незаменимой для многих задач скриптования.
При отладке скрипта мы используем её чтобы посмотреть какое значение содержит на текущий момент та или иная
переменная, в сложных ситуациях мы «оборачиваем» с её помощью данные неизвестного на данный момент типа —
например для безопасного сравнения с контрольной величиной, создаем строки для вывода значений разных типов, как в
вышеприведенном примере, и наконец она позволяет нам создавать новые идентификаторы и функции.
Последний момент стоит рассмотреть немного подробнее.</p>
<p>Рантайм создание идентификаторов может понадобиться, например, при работе с
сохранением/восстановлением статуса объектов количество которых не известно
заранее — команды loadStatus и saveStatus требуют уникальную строковую величину
для идентификации сохраненного статуса. Мы можем создать его при помощи format:</p>
<pre class="hl sqf">_statusID = format ["statusID%1", random 10000]</pre>
<p>вместо random стоит использовать счетчик statusID'ов — при создании
очередного идентификатора инкрементируйте этот счетчик, обеспечивая тем самым уникальность id'ов.</p>
<p>Похоже дело обстоит и при создании новых переменных,
только здесь мы создаем новый код, а затем выполняем его:</p>
<pre class="hl sqf">call format ["new_variable_n%1 = %1", _count_of_variables]</pre>

<h4 id="toc14">Массивы или переменные с типом Array</h4>

<p id="toc15">Если обычная переменная может содержать лишь одно значение, то для хранения ряда
значений предназначен <i>массив</i>. Непосредственно указанный массив записывается как
заключенный в прямоугольные скобки набор величин перечисленных через запятую:</p>
<pre class="hl sqf">["item 0", "item 1", "item 2", "item 3"]</pre>
<p>Один массив может содержать значения различных типов, например, такой массив вполне возможен:</p>
<pre class="hl sqf">["просто строка", 1976, player, group player, <em>false</em>, <em>east</em>]</pre>

<h5 id="toc16">Операции над массивами</h5>

<p>В отличии от обычной переменной, для доступа к значению которой достаточно указания имени,
в случае с массивом необходимо указывать также <i>индекс</i> элемента
массива к которому мы хотим обратиться.
Например определим массив из трех элементов:</p>
<pre class="hl sqf">_girlfriends = ["Маша", "Даша", "Глаша"]</pre>

<p id="toc17">Для получения значения нужного элемента, используется команда <tt>select</tt>.
Синаксис команды:</p>
<pre class="code"><i>array</i> select <i>index</i></pre>
Здесь: <i>array</i> — массив, чей элемент подлежит чтению, а <i>index</i> — индекс читаемого элемента.
Такая конструкция возвратит прочитанное значение.
<p>Выведем последний элемент массива на экран командой <tt>hint</tt></p>
<pre class="hl sqf">hint ( _girlfriends select 2 )</pre>

<p>Я не опечатался указав в качестве индекса последнего элемента число 2, эта строка действительно
выведет подсказку «<b>Глаша</b>».
Дело в том, что в скриптах офп как и во многих других языках элементы массивов индексируются с нуля, то есть в нашем
случае элемент со значением «Маша» будет иметь индекс равный нулю,
со значением «Даша» — единице и со значением «Глаша» — двойке.
Это не следует понимать как то, что первый элемент имеет индекс ноль (как, случается, объясняют на форумах),
ибо такое объяснение ведет к путанице и непониманию. Просто избегайте самого понятия «первый элемент» и
используйте классическое «нулевой элемент». (как пример — прописная истина: в байте восемь
бит — с нулевого по седьмой).</p>
<p id="toc18">Присваивание значения конкретному элементу массива осуществляется командой set имеющей следующий синтаксис:</p>
<pre class="code"><i>array</i> set [<i>index</i>, <i>value</i>]</pre>
<p>Здесь:</p>
<ul class="none">
<li><i>array</i> — модифицируемый массив;
</li><li><i>index</i> — индекс устанавливаемого элемента;
</li><li><i>value</i> — устанавливаемое значение.
</li></ul>
<p>Присвоить шестому элементу массива строку "some string":</p>
<pre class="hl sqf">_my_array set [6, "some string"]</pre>
<p>Если элемент с указанным индексом не существовал ранее, то он будет создан.
В случае когда индекс создаваемого элемента указывает за границы массива размер массива будет увеличен; если массив был увеличен более чем на одно место, то в него будет добавлено требуемое количество новых элементов инициализированных в null.</p>
<p><i>Примечание: однако избегайте обращения к несуществующим элементам массива — если индекс элемента к которому
произошла попытка чтения больше размера самого массива, то офп выдаст сообщение об ошибке (по странной причине, это ошибка деления на ноль).
Попытка чтения несуществующего элемента с индексом равным размеру массива возвращает nil.</i></p>
<p>Добавить новый элемент в конец массива:</p>
<pre class="hl sqf">_stack set [count _stack, "new value"]</pre>
<p>Команда count возвращает текущий размер массива, и поскольку индекс верхнего элемента всегда на единицу меньше размера массива, код добавит новый элемент.</p>
<p>Прочитать последний элемент в переменную _top</p>
<pre class="hl sqf">_top = _stack select (count _stack - 1)</pre>
<p id="toc19">Изменить размер массива можно командой resize. Так мы уменьшаем размер массива на единицу, удаляя тем самым последний элемент:</p>
<pre class="hl sqf">_stack resize (count _stack - 1)</pre>
<p>Безопасно удалить последний элемент массива:</p>
<pre class="hl sqf">if (count _stack != 0) then {
    _stack resize (count _stack - 1)
}</pre>
<p>Команда set требует указания существующего массива, так что если вы собираетесь добавлять элементы в массив динамически, то массив надо создать заранее:</p>
<pre class="hl sqf">_new_array = []</pre>
<p id="toc20">Важно понимать, что переменная с типом array — это лишь ссылка на сам массив.
Поэтому, если вы присваиваете переменной _x_array другую переменную _y_array содержащую массив,
то создания нового массива и копирования в него существующего не происходит,
и _x_array будет указывать на тот же массив, что и _y_array:</p>
<pre class="hl sqf">_real_array = ["Маша", "любит", "Пашу"];

// запомним текущее состояние массива
_morning_of_love = format ["%1", _real_array];

_spy_array = _real_array;

_spy_array set [1, "терпеть не может"];

// запомним текущее состояние массива
_evening_of_love = format ["%1", _real_array];

// смотрим результат
hint ( _morning_of_love + "\n\n" + _evening_of_love );</pre>
<p>Как видим изменение _spy_array привело к тому же изменению в _real_array.</p>
<p>Если вам надо получить копию массива воспользуйтесь унарным плюсом.
Скопировать _y_array в _x_array:</p>
<pre class="hl sqf">_x_array = +_y_array</pre>

<p><i>Примечание: унарный плюс используемый совместно с операндом с типом array возвращает его копию.</i></p>
<pre class="hl sqf">_real_array = ["Маша", "любит", "Пашу"];

// запомним текущее состояние массива
_morning_of_love = format ["%1", _real_array];

_spy_array = +_real_array;

_spy_array set [1, "терпеть не может"];

// запомним текущее состояние массива
_evening_of_love = format ["%1", _real_array];

// смотрим результат
hint ( _morning_of_love + "\n\n" + _evening_of_love );</pre>

<p>Теперь видим, что несмотря на происки врагов любовь Маши нисколько не ослабевает. Вот она сила унарного плюса.</p>
<p><i class="nlremark">Примечание: в действительности не только массивы, но
все переменные языка реализуются ссылками. Это становится очевидным, если вспомнить, что переменные полиморфны
(принимают значения любого типа), и информацию о типе содержит не сама переменная, а её значение.
Однако поскольку их поведение никак не даёт об этом знать (при присваивании, например, числа происходит его копирование)
это совершенно прозрачно для использования.</i></p>
<p id="toc21">Конкатенация (объединение) массивов осуществляется оператором «+»  (плюс).
То есть мы фактически складываем два массива, например: <tt>["A", "B", "C"] + ["X", "Y", "Z"]</tt> вернёт
новый объединенный массив <tt>["A", "B", "C", "X", "Y", "Z"]</tt></p>
<p id="toc23">Например, если вы хотите использовать массив в качестве очереди, то удобнее вставлять элементы в начало, а снимать с конца:</p>
<pre class="hl sqf">_queue = [new_value] + _queue;          // добавить элемент в начало
_top = _queue select (count _queue - 1) // прочитать элемент с конца
_queue resize (count _queue - 1)        // удалить последний элемент</pre>
<p>Допустим у нас есть мужские и женские имена:</p>
<pre class="hl sqf">_male_names = ["Петр", "Василий", "Генадий"]
_female_names = ["Вера", "Надя", "Люба"]</pre>
<p>Теперь получим список всех имен:</p>
<pre class="hl sqf">_human_names = _male_names + _female_names
hint format ["%1", _human_names]</pre>
<p id="toc22">Аналогично можно вычитать массивы:</p>
<pre class="hl sqf">_male_only_names = _human_names - _female_names
hint format ["%1", _male_only_names]</pre>
<p>Вычитание фактически удаляет из левого массива все элементы чьи значения совпадают с элементами в правом массиве.
Например так можно удалить все дубликаты в массиве:</p>
<pre class="hl sqf">_i = 0;
while { count _array != _i } do {
    _value = _array select _i;
    _array = [_value] + ( _array - [_value] );
    _i = _i + 1;
}</pre>
<p>Удалить восьмой элемент массива:</p>
<pre class="hl sqf">_array = _array - [ _array select 8 ]</pre>
<p>У этого способа есть один недостаток — он сработает корректно,
лишь в том случае, если массив не содержит дублирующихся элементов, иначе могут быть
удалены все элементы со значением равным удаляемому.
Зачастую можно поступить так:</p>
<pre class="hl sqf">_array set [8, objNull];
_array = _array - [objNull];</pre>
<p>Этот способ не универсален, и в общем случае вместо objNull нужно использовать любое уникальное значение гарантированно
не встречающееся в массиве, а сам выбор такого значения для каждого конкретного случая остается за Вами.</p>
<p>Надо помнить, что все элементы чьи индексы старше удаляемого, будут сдвинуты влево (в сторону младших индексов).</p>
<p id="subtraction_array">Вычитание не будет работать, если элементы массивов, сами в свою очередь являются массивами;
этому есть вполне объяснимая причина — для нахождения совпадающих элементов необходимо
провести сравнение <!--(выполнить проверку равенства)--> всех (или некоторых, зависит от реализации) элементов массива.
Однако вспомним, что мы не можем сравнивать массивы, и похоже этой операции действительно не существует ни в каком виде.
По этой же причине выражение « <tt>some_array in [some_array]</tt> » никогда не даст true,
как не покажется это странным на первый взгляд.</p>
<p><i>Примечание: это действительно обидно, если учесть, что не всегда нужно поэлементное сравнение,
например, когда нужно удалить конкретный подмассив, а не любой, совпадающий по структуре и содержанию,
и поэтому вполне достаточно проверки на идентичность двух ссылок (каким бы ни было их внутреннее представление)</i></p>
<p>Поэтому, если у вас вдруг действительно возникла необходимость удалить подмассив,
используйте технику из предыдущего примера.</p>
<p>Как мы уже знаем, для обхода всех элементов массива существует команда foreach.
Правый операнд foreach — массив для каждого элемента которого будет выполнен блок (последовательность команд заключенная в фигурные скобки) указанный левым операндом.
Текущий элемент массива доступен в блоке как зарезервированная переменная _x.</p>
<p>Представим, что обладатели вышеуказанных мужских имен — дети некоего Епифана<del> Поликарпиия</del>:</p>
<pre class="hl sqf">_epiphans_children = [];
{
    _epiphans_children set [count _epiphans_children, _x + " Епифанович"]

} foreach _male_only_names;

hint format ["%1", _epiphans_children]</pre>
<p>Проверить находится ли нужный нам элемент в массиве позволяет команда in:</p>
<pre class="hl sqf">if (name player in _epiphans_children) then {
    hint "Я давно подозревал, что с вами не все в порядке!"
} else {
    hint "Я счастлив знать, что вас избежала сия участь!"
}</pre>
<p>Мы уже видели как использовать команду count для получения количества всех элементов (т.е. размера) массива.
Но существует и другая форма использования этой команды - она позволяет узнать количество лишь тех элементов
массива которые удовлетворяют определенному условию. её синтаксис похож на синтаксис foreach с той лишь разницей,
что блок должен заканчиваться выражением возвращающем true или false, а сама команда вернёт количество элементов
для которых выражение оказалось справедливо.</p>
<pre class="hl sqf">_epiphans_crew_number = {
    name _x in _epiphans_children
} count crew vehicle player;

if ( _epiphans_crew_number &gt; 1 ) then {
    hint format ["%1 идиота на один танк — это слишком!", _epiphans_crew_number]
}</pre>
<p>Команды countEnemy и countFriendly возвращают
количество юнитов в переданном массиве
являющихся противниками или союзниками (соответственно) для указанного юнита:</p>
<pre class="hl sqf">hint format [
    "игроку известно о %1 юнитах противника и %2 своих юнитов в зоне триггера",
    player countEnemy list battle_zone_trigger,
    player countFriendly list battle_zone_trigger
]</pre>
<p>Если в секторе нет врагов известных Стрелке:</p>
<pre class="hl sqf">if (Strelka countEnemy list sector_trigger == 0) then {
    Strelka sideChat "Наверно они опять заползли под тот камень, из под которого выползли вначале!"
}</pre>
<p>Команда countSide возвращает количество юнитов принадлежащих указанной стороне:</p>
<pre class="hl sqf">hint format [
    "%1 своих в зоне триггера",
    side player countSide list battle_zone_trigger,
]</pre>
<p>Команда countType позволяет узнать количество объектов принадлежащих определенному классу или являющихся его потомками (по иерархии наследования в конфиге игры)</p>
<pre class="hl sqf">hint format [
    "%1 человек в зоне триггера",
    "man" countType list battle_zone_trigger,
]</pre>
<p>Часто команду countType используют для проверки на принадлежность объекта классу (или подклассу):</p>
<pre class="hl sqf">if ( "tank" countType [_my_unit] != 0 ) then {
    hint "это бронетехника"
}</pre>
<!--p&gt;Также, обратите внимание на команду countUnknown — её описание вы найдете в комрефе.-->
<p>Получить случайный элемент массива можно сгенерировав индекс командой random:</p>
<pre class="hl sqf">_greetings = [
    "Привет",
    "Здраствуй",
    "Хай",
    "Здоровеньки булы",
    "Доброго времени суток",
    "Пешуиспацтала"
];

hint ( _greetings select ((random count _greetings) - .5) )
     + ", "
     + name player
     + "!";</pre>
<p>Команда random возвращает псевдослучайное значение в диапазоне от ноля (0) до указанного правым операндом.
При использовании в качестве индекса массива вещественного (дробного, нецелого) значения индекс округляется к ближайшему целому
(т.о. даже отрицательное значение большее или равное <nobr>-0.5</nobr> будет округлено до ноля).
Полученное случайное число мы перемещаем в диапазон от <nobr>( -0.5 )</nobr> до <nobr>( count array - 0.5 )</nobr>.
Таким образом, при соблюдении неравенства:</p>
<pre class="text">( -0.5 ) &lt;= index &lt; ( count array - 0.5 )</pre><!-- Flea, thanx -->
<p>мы всегда будем укладываться в область допустимых индексов.</p>
<p>Это решение даёт максимально равномерное распределение
(настолько хорошее, насколько хорош сам генератор псевдослучайных чисел)
<del>Можно было бы использовать ( random ( count _greetings - 1 ) ),
однако при этом крайние элементы массива выбирались бы реже других.</del></p>

<h5 id="toc24">Вложенные массивы</h5>

<p><i>Двухмерные массивы</i> реализуются в скриптах офп как массив массивов.
Например адресную книгу пришлось бы организовывать так:</p>
<pre class="hl sqf">_contacts = [
    ["Петр Хлыщ", "Бобруйск, дом 103 кв. 42", 899-67-23],
    ["Федр Ртутный", "Занзибар, дом 593 кв. 98", 618-59-14],
    ["Мальчег-Спальчег", "Албания, первый поворот за гастрономом, контейнер справа", "911"]
]</pre>
<p>Теперь <tt>(_contacts select 1)</tt> будет возвращать массив:</p>
<pre class="hl sqf">["Федр Ртутный", "Занзибар, дом 593 кв. 98", 618-59-14]</pre>
<p>Соответственно <tt>((_contacts select 1) select 2)</tt> — вернёт номер телефона мистера Ртутного.
Представим, что Федр сменил место жительства и нам теперь нужно изменить его адрес в нашей книге:</p>
<pre class="hl sqf">(_contacts select 1) set [1, "Где-то в Англии"]</pre>
<p>Если мы собираемся неоднократно обращаться к подмассиву,
имеет смысл записать ссылку на него во временную переменную и работать с ней:</p>
<pre class="hl sqf">_refArr = _contacts select 1  // теперь «_contacts select 1» и _refArr
                              // ссылаются на один и тот же массив
_refArr set [1, "Где-то в Англии"]
_refArr set [2, 534-74-35]</pre>
<p>Заметим, что, поскольку _refArr не копия «_contacts select 1», а ссылка на этот подмассив,
записывать его обратно не надо —
все манипуляции над переменной _refArr в действительности совершаются над массивом на который она ссылается.</p>
<p><i>Примечание. Очевидно, но на всякий случай поясним: «все манипуляции» — это resize, set, select; присваивание-же любой
величины изменит значение переменной — она перестанет указывать (ссылаться) на прежний массив.</i></p>
<p>Пример с адресной книгой в военной игре может показаться надуманным, но он (как и большинство простых примеров здесь) демонстрирует возможности языка, а не решает реальную задачу.</p>
<p>Более жизненная ситуация — предположим, что у нас есть триггер и мы хотим
узнать названия и количество стволов юнитов находящихся в данном триггере в формате который
принимают такие команды как <tt>addWeaponCargo</tt> (массив вида ["gun_classname", number]). Собрать все стволы в один массив не представляется сложным:</p>
<pre class="hl sqf">_all_weapons = [];
{ // для всех юнитов попавших в триггер
    { // для всех членов экипажа этого юнита
        _all_weapons = _all_weapons + weapons _x
    } foreach crew _x
} foreach list battle_zone_trigger</pre>
<p>Здесь мы создаем новый массив <tt>_all_weapons</tt> и затем в цикле присоединяем к нему массивы возвращаемые командой <tt>weapons</tt>.</p>
<p><i>Примечание:<br>выражение «<tt>list battle_zone_trigger</tt>» возвращает все объекты входящие на данный момент в триггер с именем battle_zone_trigger (см. описание команды list в комрефе);
<br>команда crew возвращает массив юнитов являющихся членами экипажа указанного юнита, экипажем человека будет сам человек.
Таким простым способом можно избежать лишних проверок, и заодно в список не попадет оружие танков или вертолетов.
</i></p>
<p>Теперь нам надо получить итоговый массив, при этом в нем не должно встречаться одинаковых элементов — вместо
нескольких одинаковых строк (названия классов стволов) мы будем записывать
один двухместный массив вида ["название_класса_ствола", количество_таких_стволов]:</p>
<pre class="hl sqf">_weapons_collection = [];

while { count _all_weapons != 0 } do {
    _remained_weapons = _all_weapons - [_all_weapons select 0];
    _weapons_collection set [
        count _weapons_collection,
        [
            _all_weapons select 0,
            count _all_weapons - count _remained_weapons
        ]
    ];
    _all_weapons = _remained_weapons;
};

_weapons_collection</pre>
<p>Рассмотрим этот код построчно.</p>
<p>Первой строкой мы создаем _weapons_collection, это тот самый массив который мы хотим получить.</p>
<p>Далее мы организуем цикл который будет выполняться до исчерпания исходного массива _all_weapons (по ходу цикла мы будем его уменьшать)</p>
<p>В цикле мы будем брать нулевой элемент _all_weapons, подсчитывать количество его вхождений в массив,
записывать эти данные в _weapons_collection, а затем сокращать _all_weapons удалением из него этого нулевого элемента.</p>
<p>В первой строке цикла, вычитанием из _all_weapons его нулевого элемента (будут вычтены все вхождения такого элемента в массив)
мы получаем сокращенный массив _remained_weapons.
В данный момент в «_all_weapons select 0» находится имя класса ствола, и соответственно
размер _remained_weapons будет меньше размера _all_weapons на количество таких стволов в _all_weapons.</p>
<p>Второй командой цикла мы добавляем в формируемый _weapons_collection двухместный массив вида:</p>
<pre class="hl sqf">[
    _all_weapons select 0,
    count _all_weapons - count _remained_weapons
]</pre>
<p>Как уже сказано выше — « <tt>_all_weapons select 0</tt> » — это название добавляемого ствола, а разница
« <tt> count _all_weapons - count _remained_weapons </tt> » — вернёт количество этих стволов в исходном массиве _all_weapons.
То есть, это именно такой массив который «скушают» команды аналогичные addWeaponCargo, что нам и требовалось в постановке задачи.</p>
<p>Третья и последняя команда в теле цикла присваивает переменной _all_weapons массив _remained_weapons,
а так как он усеченная копия _all_weapons (см. первую строку цикла), то после исчерпания всех элементов _all_weapons
цикл благополучно закончится, сформировав нужный нам _weapons_collection.</p>
<p>Теперь, с полученным массивом мы можем делать разные вещи — например погрузить все оружие в машинy:</p>
<pre class="hl sqf">{ removeAllWeapons _x } foreach list battle_zone_trigger;
{ _my_car addWeaponCargo _x } foreach _weapons_collection;</pre>
<p><del>Я думаю, что по массивам теперь можно закончить, но мы еще обязательно вернемся к ним при рассмотрении
некоторых структур данных и алгоритмов.</del></p>

<h5 id="toc25">Разделяемые области данных</h5>

<p>Еще одно интересное применение массивов никак нельзя не упомянуть.</p>
<p>Важное свойство массива — отсутствие копирования при присваивании, позволяет
нам использовать его для ряда интересных и
порой очень удобных инструментов.</p>
<p>Речь идет о «наведении мостов» между параллельно выполняющимися скриптами.
Например в следующем примере один из них, «родительский», ждёт пока не будет выполнен
другой, «дочерний»:</p>
<pre class="hl sqf">;parent.sqs

; [флаг_готовности, значение_задержки, сюда_будет_записано_приветствие]
_pipe = [<em>false</em>, 10, ""]

_pipe exec "child.sqs"

@ ( _pipe select 0 )

hint ( _pipe select 2 )

exit</pre>
<pre class="hl sqf">;child.sqs

; задержка заданная в «parent.sqs»
~ ( _this select 1 )

; вернем приветствие
_this set [2, "Hello, father!"]

; установим флаг готовности
_this set [0, <em>true</em>]

exit</pre>

<p>Как видно из примера, мы можем легко создавать разделяемые между
несколькими скриптами области данных, что и позволяет синхоронизировать их работу, и многое, многое другое.</p>

<h4 id="toc26">Переменные других типов</h4>

<h5 id="toc27">Переменные ссылающиеся на объекты, значения с типом Object</h5>

<p>Еще одним важным типом является Object. Значения этого типа являются, фактически, ссылками на игровые объекты.
Из операций доступна лишь проверка на идентичность, а все основные манипуляции с такими
значениями обеспечиваются различными командами. Рассматривать их здесь мы не будем, так
как это, <span tooltip="Около ста семидесяти принимающих или возвращающих значения с этим типом">пожалуй, большая часть существующих команд языка</span>, и все они достаточно хорошо описаны в комрефе.</p>

<p>Существует специальное значение objNull, возвращаемое одноименной командой, обозначающее отсутствие объекта.
Это значение может возвращаться многими командами в случаях когда требуемого объекта не существует. Также
его могут принимать некоторые команды, например doTarget, для отмены цели.
Однако мы не можем использовать objNull при проверках, <span tooltip="На самом деле я просто повторяю ту чушь, что поведали нам бисы в комрефе, в действительности проще сказать, что нельзя сравнивать objNull, а почему нельзя — потому ли, что оно даже самом себе не равно, или по иной причине — совсем не интересно. Больше хочется сказать, что сделано тупо ((">так как это значение ничему не равно</span>;
во всех таких случаях используйте команду isNull.</p>

<h5 id="toc28">Переменные идентифицирующие группы юнитов, значения с типом Group</h5>

<p>Значения с типом Group идентифицируют группы юнитов.
Команда group возвращает группу к которой принадлежит юнит. Здесь также доступна лишь проверка идентичности —
мы можем только сравнивать группы операторами «==» и «!=»,
а основной способ использования значений Group — многочисленные команды.</p>
<p>Аналогично случаю с типом Object, для групп существует команда grpNull возвращающая
«отсутствие существования группы», и её также нельзя использовать в сравнениях —
проверка на отсутствие группы должна осуществляться с помощью isNull.
Например, группа перестанет существовать (group вернёт grpNull) через некоторое
время после гибели последнего члена группы.</p>
<p><i>Примечеание: Однако группа существует бесконечно долго, если последний член группы был удален с помощью deleteVehicles.</i></p>

<h5 id="toc29">Переменные идентифицирующие стороны, значения с типом Side</h5>

<p>Существует лишь несколько значений этого типа, поэтому перечислим их полностью:
east, west, resistance, civilian, logic, enemy, friendly.
Первые четыре идентифицируют противоборствующие стороны, и они всегда доступны
посредством одноименных команд:</p>
<pre class="text">
east       — <s>всегда возвращает сторону east, приведение к строке даёт "EAST";</s>
west       — <s>всегда возвращает сторону west, приведение к строке даёт "WEST";</s>
resistance — <s>всегда возвращает сторону resistance, приведение к строке даёт "GUER";</s>
civilian   — <s>всегда возвращает сторону civilian, приведение к строке даёт "CIV".</s>
</pre>
<p>Узнать сторону которой принадлежит некий юнит можно командой side:</p>
<pre class="hl sqf">hint format ["%1", side player]</pre>
<p>Возможна проверка идентичности сторон:</p>
<pre class="hl sqf">if ( side player == <em>resistance</em> ) then {
    hint ( name player + ", вы повстанец." )
}</pre>

<p>Команда sideLogic всегда возвращает сторону logic, с её помощью можно проверить является ли
объект лоджиком:</p>
<pre class="hl sqf">if ( side unknown_object == sideLogic ) then {
    hint "Это лоджик"
}</pre>
<p>Стороны enemy, friendly предусмотрены в игре (и в главном конфиге игры есть определения этих сторон)
однако, насколько я знаю, не существует юнитов принадлежащих этим сторонам.</p>

<div class="author">Copyright © <a href="https://code.google.com/u/114481294814027320015/" rel="author">DenVdmj</a>, 2006–2014.</div>
</body>
</html>

